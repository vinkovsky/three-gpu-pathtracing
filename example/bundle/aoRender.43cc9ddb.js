var t="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:{},e={},n={},a=t.parcelRequire5b70;null==a&&((a=function(t){if(t in e)return e[t].exports;if(t in n){var a=n[t];delete n[t];var i={id:t,exports:{}};return e[t]=i,a.call(i.exports,i,i.exports),i.exports}var r=new Error("Cannot find module '"+t+"'");throw r.code="MODULE_NOT_FOUND",r}).register=function(t,e){n[t]=e},t.parcelRequire5b70=a);var i=a("ilwiq"),r=a("RPVlj"),o=a("7lx9d"),l=a("5Rd1x"),s=a("cVdfP"),d=a("kp7Te"),c=a("jiuw3"),m=(i=a("ilwiq"),a("9fZ6X")),u=a("8Zfx2"),f=a("kiOyI"),p=a("jJR4H"),v=a("kmALz");class h extends m.MaterialBase{get normalMap(){return this.uniforms.normalMap.value}set normalMap(t){this.uniforms.normalMap.value=t,this.setDefine("USE_NORMALMAP",t?null:"")}get normalMapType(){return i.TangentSpaceNormalMap}set normalMapType(t){if(t!==i.TangentSpaceNormalMap)throw new Error("AmbientOcclusionMaterial: Only tangent space normal map are supported")}constructor(t){super({defines:{SAMPLES:10},uniforms:{bvh:{value:new u.MeshBVHUniformStruct},radius:{value:1},seed:{value:0},normalMap:{value:null},normalScale:{value:new i.Vector2(1,1)}},vertexShader:"\n\n\t\t\t\tvarying vec3 vNorm;\n\t\t\t\tvarying vec3 vPos;\n\n\t\t\t\t#if defined(USE_NORMALMAP) && defined(USE_TANGENT)\n\n\t\t\t\t\tvarying vec2 vUv;\n\t\t\t\t\tvarying vec4 vTan;\n\n\t\t\t\t#endif\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 mvPosition = vec4( position, 1.0 );\n\t\t\t\t\tmvPosition = modelViewMatrix * mvPosition;\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t\tmat3 modelNormalMatrix = transpose( inverse( mat3( modelMatrix ) ) );\n\t\t\t\t\tvNorm = normalize( modelNormalMatrix * normal );\n\t\t\t\t\tvPos = ( modelMatrix * vec4( position, 1.0 ) ).xyz;\n\n\t\t\t\t\t#if defined( USE_NORMALMAP ) && defined( USE_TANGENT )\n\n\t\t\t\t\t\tvUv = uv;\n\t\t\t\t\t\tvTan = tangent;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t}\n\n\t\t\t",fragmentShader:`\n\t\t\t\t#define RAY_OFFSET 1e-4\n\n\t\t\t\tprecision highp isampler2D;\n\t\t\t\tprecision highp usampler2D;\n\t\t\t\tprecision highp sampler2DArray;\n\t\t\t\t#include <common>\n\t\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\t\t// bvh\n\t\t\t\t${u.shaderStructs}\n\t\t\t\t${u.shaderIntersectFunction}\n\n\t\t\t\t// uniform structs\n\t\t\t\t${f.materialStructGLSL}\n\n\t\t\t\t// rand\n\t\t\t\t${v.pcgGLSL}\n\n\t\t\t\t// common\n\t\t\t\t${p.shapeSamplingGLSL}\n\n\t\t\t\tuniform BVH bvh;\n\t\t\t\tuniform int seed;\n\t\t\t\tuniform float radius;\n\n\t\t\t\tvarying vec3 vNorm;\n\t\t\t\tvarying vec3 vPos;\n\n\t\t\t\t#if defined(USE_NORMALMAP) && defined(USE_TANGENT)\n\n\t\t\t\t\tuniform sampler2D normalMap;\n\t\t\t\t\tuniform vec2 normalScale;\n\t\t\t\t\tvarying vec2 vUv;\n\t\t\t\t\tvarying vec4 vTan;\n\n\t\t\t\t#endif\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\trng_initialize( gl_FragCoord.xy, seed );\n\n\t\t\t\t\t// compute the flat face surface normal\n\t\t\t\t\tvec3 fdx = vec3( dFdx( vPos.x ), dFdx( vPos.y ), dFdx( vPos.z ) );\n\t\t\t\t\tvec3 fdy = vec3( dFdy( vPos.x ), dFdy( vPos.y ), dFdy( vPos.z ) );\n\t\t\t\t\tvec3 faceNormal = normalize( cross( fdx, fdy ) );\n\n\t\t\t\t\t// find the max component to scale the offset to account for floating point error\n\t\t\t\t\tvec3 absPoint = abs( vPos );\n\t\t\t\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\n\t\t\t\t\tvec3 normal = vNorm;\n\n\t\t\t\t\t#if defined( USE_NORMALMAP ) && defined( USE_TANGENT )\n\n\t\t\t\t\t\t// some provided tangents can be malformed (0, 0, 0) causing the normal to be degenerate\n\t\t\t\t\t\t// resulting in NaNs and slow path tracing.\n\t\t\t\t\t\tif ( length( vTan.xyz ) > 0.0 ) {\n\n\t\t\t\t\t\t\tvec2 uv = vUv;\n\t\t\t\t\t\t\tvec3 tangent = normalize( vTan.xyz );\n\t\t\t\t\t\t\tvec3 bitangent = normalize( cross( normal, tangent ) * vTan.w );\n\t\t\t\t\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\n\t\t\t\t\t\t\tvec3 texNormal = texture2D( normalMap, uv ).xyz * 2.0 - 1.0;\n\t\t\t\t\t\t\ttexNormal.xy *= normalScale;\n\t\t\t\t\t\t\tnormal = vTBN * texNormal;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tnormal *= gl_FrontFacing ? 1.0 : - 1.0;\n\n\t\t\t\t\tvec3 rayOrigin = vPos + faceNormal * ( maxPoint + 1.0 ) * RAY_OFFSET;\n\t\t\t\t\tfloat accumulated = 0.0;\n\t\t\t\t\tfor ( int i = 0; i < SAMPLES; i ++ ) {\n\n\t\t\t\t\t\t// sample the cosine weighted hemisphere and discard the sample if it's below\n\t\t\t\t\t\t// the geometric surface\n\t\t\t\t\t\tvec3 rayDirection = sampleHemisphere( normalize( normal ), rand4().xy );\n\n\t\t\t\t\t\t// check if we hit the mesh and its within the specified radius\n\t\t\t\t\t\tfloat side = 1.0;\n\t\t\t\t\t\tfloat dist = 0.0;\n\t\t\t\t\t\tvec3 barycoord = vec3( 0.0 );\n\t\t\t\t\t\tvec3 outNormal = vec3( 0.0 );\n\t\t\t\t\t\tuvec4 faceIndices = uvec4( 0u );\n\n\t\t\t\t\t\t// if the ray is above the geometry surface, and it doesn't hit another surface within the specified radius then\n\t\t\t\t\t\t// we consider it lit\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tdot( rayDirection, faceNormal ) > 0.0 &&\n\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t! bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, outNormal, barycoord, side, dist ) ||\n\t\t\t\t\t\t\t\tdist > radius\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t) {\n\n\t\t\t\t\t\t\taccumulated += 1.0;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgl_FragColor.rgb = vec3( accumulated / float( SAMPLES ) );\n\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t}\n\n\t\t\t`}),this.setValues(t)}}var g=function(){var t=0,e=document.createElement("div");function n(t){return e.appendChild(t.dom),t}function a(n){for(var a=0;a<e.children.length;a++)e.children[a].style.display=a===n?"block":"none";t=n}e.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",e.addEventListener("click",(function(n){n.preventDefault(),a(++t%e.children.length)}),!1);var i=(performance||Date).now(),r=i,o=0,l=n(new g.Panel("FPS","#0ff","#002")),s=n(new g.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var d=n(new g.Panel("MB","#f08","#201"));return a(0),{REVISION:16,dom:e,addPanel:n,showPanel:a,begin:function(){i=(performance||Date).now()},end:function(){o++;var t=(performance||Date).now();if(s.update(t-i,200),t>=r+1e3&&(l.update(1e3*o/(t-r),100),r=t,o=0,d)){var e=performance.memory;d.update(e.usedJSHeapSize/1048576,e.jsHeapSizeLimit/1048576)}return t},update:function(){i=this.end()},domElement:e,setMode:a}};g.Panel=function(t,e,n){var a=1/0,i=0,r=Math.round,o=r(window.devicePixelRatio||1),l=80*o,s=48*o,d=3*o,c=2*o,m=3*o,u=15*o,f=74*o,p=30*o,v=document.createElement("canvas");v.width=l,v.height=s,v.style.cssText="width:80px;height:48px";var h=v.getContext("2d");return h.font="bold "+9*o+"px Helvetica,Arial,sans-serif",h.textBaseline="top",h.fillStyle=n,h.fillRect(0,0,l,s),h.fillStyle=e,h.fillText(t,d,c),h.fillRect(m,u,f,p),h.fillStyle=n,h.globalAlpha=.9,h.fillRect(m,u,f,p),{dom:v,update:function(s,g){a=Math.min(a,s),i=Math.max(i,s),h.fillStyle=n,h.globalAlpha=1,h.fillRect(0,0,l,u),h.fillStyle=e,h.fillText(r(s)+" "+t+" ("+r(a)+"-"+r(i)+")",d,c),h.drawImage(v,m+o,u,f-o,p,m,u,f-o,p),h.fillRect(m+f-o,u,o,p),h.fillStyle=n,h.globalAlpha=.9,h.fillRect(m+f-o,u,o,r((1-s/g)*p))}}};var y=g,w=(u=a("8Zfx2"),a("kkvoh")),x=a("7ePFa");let S,M,P,b,T,E,F,N,R,A,L,_;const z={resolutionScale:1/window.devicePixelRatio,radius:2,samplesPerFrame:2,accumulate:!0,pause:!1};function O(){const t=window.innerWidth,e=window.innerHeight,n=window.devicePixelRatio*z.resolutionScale;F.setSize(t*n,e*n),N.setSize(t*n,e*n),S.setSize(t,e),S.setPixelRatio(window.devicePixelRatio),P.aspect=t/e,P.updateProjectionMatrix(),D()}function D(){L=0,_=0}function U(){if(requestAnimationFrame(U),T.update(),R.forEach((t=>{z.pause||t.seed++,t.radius=z.radius,t.setDefine("SAMPLES",z.samplesPerFrame)})),0===L||!z.pause){if(L++,_+=z.samplesPerFrame,z.accumulate&&!z.pause){const t=F.width,e=F.height;P.setViewOffset(t,e,Math.random()-.5,Math.random()-.5,t,e)}S.setRenderTarget(F),S.render(b,P),S.setRenderTarget(N),S.autoClear=!1,E.material.map=F.texture,E.material.opacity=z.accumulate?1/L:1,E.render(S),S.autoClear=!0}S.setRenderTarget(null),E.material.map=N.texture,E.material.opacity=1,E.render(S),A.innerText=`Samples: ${_}`}!async function(){S=new i.WebGLRenderer({antialias:!0}),S.outputEncoding=i.sRGBEncoding,document.body.appendChild(S.domElement),E=new r.FullScreenQuad(new i.MeshBasicMaterial({transparent:!0})),P=new i.PerspectiveCamera(75,window.innerWidth/window.innerHeight,.1,200),P.position.set(-4,2,3),b=new i.Scene,M=new l.OrbitControls(P,S.domElement),M.addEventListener("change",(()=>{D()})),A=document.getElementById("samples"),F=new i.WebGLRenderTarget(1,1,{type:i.FloatType,encoding:i.LinearEncoding}),N=new i.WebGLRenderTarget(1,1,{type:i.FloatType,encoding:i.LinearEncoding}),R=[];const t=new s.PathTracingSceneWorker,e=(new o.GLTFLoader).setMeshoptDecoder(d.MeshoptDecoder).loadAsync("https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/FlightHelmet/glTF/FlightHelmet.gltf").then((async e=>{const n=new i.Group,a=new i.Box3;a.setFromObject(e.scene);const r=new i.Sphere;a.getBoundingSphere(r),e.scene.scale.setScalar(2.5/r.radius),e.scene.position.y=-.25*(a.max.y-a.min.y)*2.5/r.radius,e.scene.updateMatrixWorld(),n.add(e.scene),a.setFromObject(e.scene);const o=new i.Mesh(new i.CylinderGeometry(3,3,.05,200),new i.MeshStandardMaterial({color:1710618}));return o.geometry.clearGroups(),o.position.y=a.min.y-.025,n.add(o),await w.ready,n.traverse((t=>{if(t.geometry){const e=t.geometry;!("tangent"in e.attributes)&&"normal"in e.attributes&&"uv"in e.attributes&&(t.geometry=x.computeMikkTSpaceTangents(e,w),t.geometry=x.mergeVertices(e))}})),t.generate(n)})).then((e=>{const{bvh:n}=e,a=new u.MeshBVHUniformStruct;a.updateFrom(n);const i=new Map,r=e.scene;r.traverse((t=>{if(t.isMesh){const e=t.material.normalMap;if(!i.has(e)){const n=new h({bvh:a,normalScale:t.material.normalScale,normalMap:e,normalMapType:t.material.normalMapType});i.set(e,n),R.push(n)}t.material=i.get(e)}})),b.add(r),t.dispose()}));await e,document.getElementById("loading").remove(),O(),window.addEventListener("resize",O);const n=new c.GUI;n.add(z,"resolutionScale",.1,1).onChange(O),n.add(z,"samplesPerFrame",1,10,1),n.add(z,"radius",0,4).onChange(D),n.add(z,"accumulate").onChange(D),n.add(z,"pause"),T=new y,document.body.appendChild(T.domElement),D(),U()}();
//# sourceMappingURL=aoRender.43cc9ddb.js.map

function t(t,e,r,a){Object.defineProperty(t,e,{get:r,set:a,enumerable:!0,configurable:!0})}var e="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:{},r={},a={},n=e.parcelRequire5b70;null==n&&((n=function(t){if(t in r)return r[t].exports;if(t in a){var e=a[t];delete a[t];var n={id:t,exports:{}};return r[t]=n,e.call(n.exports,n,n.exports),n.exports}var o=new Error("Cannot find module '"+t+"'");throw o.code="MODULE_NOT_FOUND",o}).register=function(t,e){a[t]=e},e.parcelRequire5b70=n),n.register("cpS3d",(function(e,r){t(e.exports,"LDrawLoader",(()=>b));var a=n("ilwiq");const o="16",i="24",s=new a.Vector3,l=new a.Vector3;class c extends a.ShaderMaterial{constructor(t){super({uniforms:a.UniformsUtils.merge([a.UniformsLib.fog,{diffuse:{value:new a.Color},opacity:{value:1}}]),vertexShader:"\n\t\t\t\tattribute vec3 control0;\n\t\t\t\tattribute vec3 control1;\n\t\t\t\tattribute vec3 direction;\n\t\t\t\tvarying float discardFlag;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <color_pars_vertex>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\t\t\t\t#include <clipping_planes_pars_vertex>\n\t\t\t\tvoid main() {\n\t\t\t\t\t#include <color_vertex>\n\n\t\t\t\t\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t\t// Transform the line segment ends and control points into camera clip space\n\t\t\t\t\tvec4 c0 = projectionMatrix * modelViewMatrix * vec4( control0, 1.0 );\n\t\t\t\t\tvec4 c1 = projectionMatrix * modelViewMatrix * vec4( control1, 1.0 );\n\t\t\t\t\tvec4 p0 = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tvec4 p1 = projectionMatrix * modelViewMatrix * vec4( position + direction, 1.0 );\n\n\t\t\t\t\tc0.xy /= c0.w;\n\t\t\t\t\tc1.xy /= c1.w;\n\t\t\t\t\tp0.xy /= p0.w;\n\t\t\t\t\tp1.xy /= p1.w;\n\n\t\t\t\t\t// Get the direction of the segment and an orthogonal vector\n\t\t\t\t\tvec2 dir = p1.xy - p0.xy;\n\t\t\t\t\tvec2 norm = vec2( -dir.y, dir.x );\n\n\t\t\t\t\t// Get control point directions from the line\n\t\t\t\t\tvec2 c0dir = c0.xy - p1.xy;\n\t\t\t\t\tvec2 c1dir = c1.xy - p1.xy;\n\n\t\t\t\t\t// If the vectors to the controls points are pointed in different directions away\n\t\t\t\t\t// from the line segment then the line should not be drawn.\n\t\t\t\t\tfloat d0 = dot( normalize( norm ), normalize( c0dir ) );\n\t\t\t\t\tfloat d1 = dot( normalize( norm ), normalize( c1dir ) );\n\t\t\t\t\tdiscardFlag = float( sign( d0 ) != sign( d1 ) );\n\n\t\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t\t#include <clipping_planes_vertex>\n\t\t\t\t\t#include <fog_vertex>\n\t\t\t\t}\n\t\t\t",fragmentShader:"\n\t\t\tuniform vec3 diffuse;\n\t\t\tuniform float opacity;\n\t\t\tvarying float discardFlag;\n\n\t\t\t#include <common>\n\t\t\t#include <color_pars_fragment>\n\t\t\t#include <fog_pars_fragment>\n\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t#include <clipping_planes_pars_fragment>\n\t\t\tvoid main() {\n\n\t\t\t\tif ( discardFlag > 0.5 ) discard;\n\n\t\t\t\t#include <clipping_planes_fragment>\n\t\t\t\tvec3 outgoingLight = vec3( 0.0 );\n\t\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t#include <color_fragment>\n\t\t\t\toutgoingLight = diffuseColor.rgb; // simple shader\n\t\t\t\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t#include <encodings_fragment>\n\t\t\t\t#include <fog_fragment>\n\t\t\t\t#include <premultiplied_alpha_fragment>\n\t\t\t}\n\t\t\t"}),Object.defineProperties(this,{opacity:{get:function(){return this.uniforms.opacity.value},set:function(t){this.uniforms.opacity.value=t}},color:{get:function(){return this.uniforms.diffuse.value}}}),this.setValues(t),this.isLDrawConditionalLineMaterial=!0}}class u extends a.LineSegments{constructor(t,e){super(t,e),this.isConditionalLine=!0}}const d=new a.Ray;function h(t){return"Part"===t||"Unofficial_Part"===t}class g{constructor(t,e){this.line=t,this.lineLength=t.length,this.currentCharIndex=0,this.currentChar=" ",this.lineNumber=e}seekNonSpace(){for(;this.currentCharIndex<this.lineLength;){if(this.currentChar=this.line.charAt(this.currentCharIndex)," "!==this.currentChar&&"\t"!==this.currentChar)return;this.currentCharIndex++}}getToken(){const t=this.currentCharIndex++;for(;this.currentCharIndex<this.lineLength&&(this.currentChar=this.line.charAt(this.currentCharIndex)," "!==this.currentChar&&"\t"!==this.currentChar);)this.currentCharIndex++;const e=this.currentCharIndex;return this.seekNonSpace(),this.line.substring(t,e)}getVector(){return new a.Vector3(parseFloat(this.getToken()),parseFloat(this.getToken()),parseFloat(this.getToken()))}getRemainingString(){return this.line.substring(this.currentCharIndex,this.lineLength)}isAtTheEnd(){return this.currentCharIndex>=this.lineLength}setToEnd(){this.currentCharIndex=this.lineLength}getLineNumberString(){return this.lineNumber>=0?" at line "+this.lineNumber:""}}class m{constructor(t){this.loader=t,this._cache={}}cloneResult(t){const e={};return e.faces=t.faces.map((t=>({colorCode:t.colorCode,material:t.material,vertices:t.vertices.map((t=>t.clone())),normals:t.normals.map((()=>null)),faceNormal:null}))),e.conditionalSegments=t.conditionalSegments.map((t=>({colorCode:t.colorCode,material:t.material,vertices:t.vertices.map((t=>t.clone())),controlPoints:t.controlPoints.map((t=>t.clone()))}))),e.lineSegments=t.lineSegments.map((t=>({colorCode:t.colorCode,material:t.material,vertices:t.vertices.map((t=>t.clone()))}))),e.type=t.type,e.category=t.category,e.keywords=t.keywords,e.author=t.author,e.subobjects=t.subobjects,e.fileName=t.fileName,e.totalFaces=t.totalFaces,e.startingBuildingStep=t.startingBuildingStep,e.materials=t.materials,e.group=null,e}async fetchData(t){let e=!1,r=0;for(;6!==r;){let n=t;switch(r){case 3:r+=1;break;case 0:n="parts/"+n,r+=1;break;case 1:n="p/"+n,r+=1;break;case 2:n="models/"+n,r+=1;break;case 4:n=t.substring(0,t.lastIndexOf("/")+1)+n,r+=1;break;case 5:e?r=6:(n=t=t.toLowerCase(),e=!0,r=0)}const o=this.loader,i=new a.FileLoader(o.manager);i.setPath(o.partsLibraryPath),i.setRequestHeader(o.requestHeader),i.setWithCredentials(o.withCredentials);try{return await i.loadAsync(n)}catch{continue}}throw new Error('LDrawLoader: Subobject "'+t+'" could not be loaded.')}parse(t,e=null){const r=this.loader,n=[],o=[],i=[],s=[],l={},c=t=>l[t]||null;let u="Model",d=null,h=null,m=null,p=0;-1!==t.indexOf("\r\n")&&(t=t.replace(/\r\n/g,"\n"));const f=t.split("\n"),C=f.length;let M=!1,b=null,w=null,y=!1,L=!0,v=!1,x=!0,k=!1;for(let t=0;t<C;t++){const e=f[t];if(0===e.length)continue;if(M){e.startsWith("0 FILE ")?(this.setData(b,w),b=e.substring(7),w=""):w+=e+"\n";continue}const C=new g(e,t+1);if(C.seekNonSpace(),C.isAtTheEnd())continue;const D=C.getToken();let E,S,T,A,N,_,F,V,I,B,R;switch(D){case"0":const e=C.getToken();if(e)switch(e){case"!LDRAW_ORG":u=C.getToken();break;case"!COLOUR":E=r.parseColorMetaDirective(C),E?l[E.userData.code]=E:console.warn("LDrawLoader: Error parsing material"+C.getLineNumberString());break;case"!CATEGORY":d=C.getToken();break;case"!KEYWORDS":const e=C.getRemainingString().split(",");e.length>0&&(h||(h=[]),e.forEach((function(t){h.push(t.trim())})));break;case"FILE":t>0&&(M=!0,b=C.getRemainingString(),w="",y=!1,L=!0);break;case"BFC":for(;!C.isAtTheEnd();){const t=C.getToken();switch(t){case"CERTIFY":case"NOCERTIFY":y="CERTIFY"===t,L=!0;break;case"CW":case"CCW":L="CCW"===t;break;case"INVERTNEXT":v=!0;break;case"CLIP":case"NOCLIP":x="CLIP"===t;break;default:console.warn('THREE.LDrawLoader: BFC directive "'+t+'" is unknown.')}}break;case"STEP":k=!0;break;case"Author:":m=C.getToken()}break;case"1":S=C.getToken(),E=c(S);const g=parseFloat(C.getToken()),f=parseFloat(C.getToken()),O=parseFloat(C.getToken()),P=parseFloat(C.getToken()),W=parseFloat(C.getToken()),G=parseFloat(C.getToken()),z=parseFloat(C.getToken()),U=parseFloat(C.getToken()),j=parseFloat(C.getToken()),q=parseFloat(C.getToken()),H=parseFloat(C.getToken()),$=parseFloat(C.getToken()),Y=(new a.Matrix4).set(P,W,G,g,z,U,j,f,q,H,$,O,0,0,0,1);let K=C.getRemainingString().trim().replace(/\\/g,"/");r.fileMap[K]?K=r.fileMap[K]:K.startsWith("s/")?K="parts/"+K:K.startsWith("48/")&&(K="p/"+K),s.push({material:E,colorCode:S,matrix:Y,fileName:K,inverted:v,startingBuildingStep:k}),k=!1,v=!1;break;case"2":S=C.getToken(),E=c(S),_=C.getVector(),F=C.getVector(),T={material:E,colorCode:S,vertices:[_,F]},o.push(T);break;case"5":S=C.getToken(),E=c(S),_=C.getVector(),F=C.getVector(),B=C.getVector(),R=C.getVector(),T={material:E,colorCode:S,vertices:[_,F],controlPoints:[B,R]},i.push(T);break;case"3":S=C.getToken(),E=c(S),A=L,N=!y||!x,!0===A?(_=C.getVector(),F=C.getVector(),V=C.getVector()):(V=C.getVector(),F=C.getVector(),_=C.getVector()),n.push({material:E,colorCode:S,faceNormal:null,vertices:[_,F,V],normals:[null,null,null]}),p++,!0===N&&(n.push({material:E,colorCode:S,faceNormal:null,vertices:[V,F,_],normals:[null,null,null]}),p++);break;case"4":S=C.getToken(),E=c(S),A=L,N=!y||!x,!0===A?(_=C.getVector(),F=C.getVector(),V=C.getVector(),I=C.getVector()):(I=C.getVector(),V=C.getVector(),F=C.getVector(),_=C.getVector()),n.push({material:E,colorCode:S,faceNormal:null,vertices:[_,F,V,I],normals:[null,null,null,null]}),p+=2,!0===N&&(n.push({material:E,colorCode:S,faceNormal:null,vertices:[I,V,F,_],normals:[null,null,null,null]}),p+=2);break;default:throw new Error('LDrawLoader: Unknown line type "'+D+'"'+C.getLineNumberString()+".")}}return M&&this.setData(b,w),{faces:n,conditionalSegments:i,lineSegments:o,type:u,category:d,keywords:h,author:m,subobjects:s,totalFaces:p,startingBuildingStep:k,materials:l,fileName:e,group:null}}getData(t,e=!0){const r=t.toLowerCase(),a=this._cache[r];return null===a||a instanceof Promise?null:e?this.cloneResult(a):a}async ensureDataLoaded(t){const e=t.toLowerCase();e in this._cache||(this._cache[e]=this.fetchData(t).then((r=>{const a=this.parse(r,t);return this._cache[e]=a,a}))),await this._cache[e]}setData(t,e){const r=t.toLowerCase();this._cache[r]=this.parse(e,t)}}function p(t,e,r,a){return(!a&&t===o||a&&t===i)&&(t=e),r[t]||null}class f{constructor(t){this.loader=t,this.parseCache=new m(t),this._cache={}}async processIntoMesh(t){const e=this.loader,r=this.parseCache,n=new Set,c=async(t,s=null)=>{const l=t.subobjects,u=[];for(let t=0,e=l.length;t<e;t++){const e=l[t],a=r.ensureDataLoaded(e.fileName).then((()=>{const t=r.getData(e.fileName,!1);return a=t.type,/primitive/i.test(a)||"Subpart"===a?c(r.getData(e.fileName),e):this.loadModel(e.fileName).catch((t=>(console.warn(t),null)));var a}));u.push(a)}const d=new a.Group;d.userData.category=t.category,d.userData.keywords=t.keywords,d.userData.author=t.author,d.userData.type=t.type,d.userData.fileName=t.fileName,t.group=d;const h=await Promise.all(u);for(let r=0,a=h.length;r<a;r++){const a=t.subobjects[r],s=h[r];if(null===s)continue;if(s.isGroup){const r=s;a.matrix.decompose(r.position,r.quaternion,r.scale),r.userData.startingBuildingStep=a.startingBuildingStep,r.name=a.fileName,e.applyMaterialsToMesh(r,a.colorCode,t.materials),r.userData.colorCode=a.colorCode,d.add(r);continue}s.group.children.length&&d.add(s.group);const l=t.lineSegments,c=t.conditionalSegments,u=t.faces,g=s.lineSegments,m=s.conditionalSegments,f=s.faces,C=a.matrix,M=a.inverted,b=C.determinant()<0,w=a.colorCode,y=w===o?i:w;for(let e=0,r=g.length;e<r;e++){const r=g[e],a=r.vertices;a[0].applyMatrix4(C),a[1].applyMatrix4(C),r.colorCode=r.colorCode===i?y:r.colorCode,r.material=r.material||p(r.colorCode,r.colorCode,t.materials,!0),l.push(r)}for(let e=0,r=m.length;e<r;e++){const r=m[e],a=r.vertices,n=r.controlPoints;a[0].applyMatrix4(C),a[1].applyMatrix4(C),n[0].applyMatrix4(C),n[1].applyMatrix4(C),r.colorCode=r.colorCode===i?y:r.colorCode,r.material=r.material||p(r.colorCode,r.colorCode,t.materials,!0),c.push(r)}for(let e=0,r=f.length;e<r;e++){const r=f[e],a=r.vertices;for(let t=0,e=a.length;t<e;t++)a[t].applyMatrix4(C);r.colorCode=r.colorCode===o?w:r.colorCode,r.material=r.material||p(r.colorCode,w,t.materials,!1),n.add(r.colorCode),b!==M&&a.reverse(),u.push(r)}t.totalFaces+=s.totalFaces}return s&&(e.applyMaterialsToMesh(d,s.colorCode,t.materials),d.userData.colorCode=s.colorCode),t};for(let e=0,r=t.faces;e<r;e++)n.add(t.faces[e].colorCode);if(await c(t),e.smoothNormals){const e=n.size>1;!function(t){for(let e=0,r=t.length;e<r;e++){const r=t[e],n=r.vertices,o=n[0],i=n[1],c=n[2];s.subVectors(i,o),l.subVectors(c,i),r.faceNormal=(new a.Vector3).crossVectors(s,l).normalize()}}(t.faces),function(t,e,r=!1){const n=100*(1+1e-10);function o(t){return`${~~(t.x*n)},${~~(t.y*n)},${~~(t.z*n)}`}function i(t,e){return`${o(t)}_${o(e)}`}function s(t,e,r){r.direction.subVectors(e,t).normalize();const a=t.dot(r.direction);return r.origin.copy(t).addScaledVector(r.direction,-a),r}function l(t){return i(t.origin,t.direction)}const c=new Set,u=new Map,h={},g=[];for(let t=0,n=e.length;t<n;t++){const n=e[t].vertices,o=n[0],d=n[1];if(c.add(i(o,d)),c.add(i(d,o)),r){const t=s(o,d,new a.Ray),e=l(t);if(!u.has(e)){s(d,o,t);const r=l(t),a={ray:t,distances:[]};u.set(e,a),u.set(r,a)}const r=u.get(e);let n=r.ray.direction.dot(o),i=r.ray.direction.dot(d);n>i&&([n,i]=[i,n]),r.distances.push(n,i)}}for(let e=0,a=t.length;e<a;e++){const a=t[e],n=a.vertices,o=n.length;for(let t=0;t<o;t++){const e=t,g=(t+1)%o,m=n[e],p=n[g],f=i(m,p);if(c.has(f))continue;if(r){s(m,p,d);const t=l(d);if(u.has(t)){const e=u.get(t),{ray:r,distances:a}=e;let n=r.direction.dot(m),o=r.direction.dot(p);n>o&&([n,o]=[o,n]);let i=!1;for(let t=0,e=a.length;t<e;t+=2)if(n>=a[t]&&o<=a[t+1]){i=!0;break}if(i)continue}}const C={index:e,tri:a};h[f]=C}}for(;;){let t=null;for(const e in h){t=h[e];break}if(null===t)break;const e=[t];for(;e.length>0;){const t=e.pop().tri,r=t.vertices,n=t.normals,o=t.faceNormal,s=r.length;for(let l=0;l<s;l++){const c=l,u=(l+1)%s,d=r[c],m=r[u];delete h[i(d,m)];const p=i(m,d),f=h[p];if(f){const r=f.tri,i=f.index,s=r.normals,l=s.length,d=r.faceNormal;if(Math.abs(r.faceNormal.dot(t.faceNormal))<.25)continue;p in h&&(e.push(f),delete h[p]);const m=(i+1)%l;n[c]&&s[m]&&n[c]!==s[m]&&(s[m].norm.add(n[c].norm),n[c].norm=s[m].norm);let C=n[c]||s[m];null===C&&(C={norm:new a.Vector3},g.push(C.norm)),null===n[c]&&(n[c]=C,C.norm.add(o)),null===s[m]&&(s[m]=C,C.norm.add(d)),n[u]&&s[i]&&n[u]!==s[i]&&(s[i].norm.add(n[u].norm),n[u].norm=s[i].norm);let M=n[u]||s[i];null===M&&(M={norm:new a.Vector3},g.push(M.norm)),null===n[u]&&(n[u]=M,M.norm.add(o)),null===s[i]&&(s[i]=M,M.norm.add(d))}}}}for(let t=0,e=g.length;t<e;t++)g[t].normalize()}(t.faces,t.lineSegments,e)}const u=t.group;return t.faces.length>0&&u.add(M(t.faces,3,!1,t.totalFaces)),t.lineSegments.length>0&&u.add(M(t.lineSegments,2)),t.conditionalSegments.length>0&&u.add(M(t.conditionalSegments,2,!0)),u}hasCachedModel(t){return null!==t&&t.toLowerCase()in this._cache}async getCachedModel(t){if(null!==t&&this.hasCachedModel(t)){const e=t.toLowerCase();return(await this._cache[e]).clone()}return null}async loadModel(t){const e=this.parseCache,r=t.toLowerCase();if(this.hasCachedModel(t))return this.getCachedModel(t);{await e.ensureDataLoaded(t);const a=e.getData(t),n=this.processIntoMesh(a);if(this.hasCachedModel(t))return this.getCachedModel(t);h(a.type)&&(this._cache[r]=n);return(await n).clone()}}async parseModel(t){const e=this.parseCache.parse(t);return h(e.type)&&this.hasCachedModel(e.fileName)?this.getCachedModel(e.fileName):this.processIntoMesh(e)}}function C(t,e){return t.colorCode===e.colorCode?0:t.colorCode<e.colorCode?-1:1}function M(t,e,r=!1,n=null){t.sort(C),null===n&&(n=t.length);const o=new Float32Array(e*n*3),i=3===e?new Float32Array(e*n*3):null,c=[],d=new Array(6),h=new a.BufferGeometry;let g=null,m=0,p=0,f=0;for(let n=0,u=t.length;n<u;n++){const u=t[n];let C=u.vertices;4===C.length&&(d[0]=C[0],d[1]=C[1],d[2]=C[2],d[3]=C[0],d[4]=C[2],d[5]=C[3],C=d);for(let t=0,e=C.length;t<e;t++){const e=C[t],r=f+3*t;o[r+0]=e.x,o[r+1]=e.y,o[r+2]=e.z}if(3===e){if(!u.faceNormal){const t=C[0],e=C[1],r=C[2];s.subVectors(e,t),l.subVectors(r,e),u.faceNormal=(new a.Vector3).crossVectors(s,l).normalize()}let t=u.normals;4===t.length&&(d[0]=t[0],d[1]=t[1],d[2]=t[2],d[3]=t[0],d[4]=t[2],d[5]=t[3],t=d);for(let e=0,r=t.length;e<r;e++){let r=u.faceNormal;t[e]&&(r=t[e].norm);const a=f+3*e;i[a+0]=r.x,i[a+1]=r.y,i[a+2]=r.z}}if(g!==u.colorCode){null!==g&&h.addGroup(m,p,c.length-1);const t=u.material;null!==t?3===e?c.push(t):2===e&&(r?c.push(t.userData.edgeMaterial.userData.conditionalEdgeMaterial):c.push(t.userData.edgeMaterial)):c.push(u.colorCode),g=u.colorCode,m=f/3,p=C.length}else p+=C.length;f+=3*C.length}p>0&&h.addGroup(m,1/0,c.length-1),h.setAttribute("position",new a.BufferAttribute(o,3)),null!==i&&h.setAttribute("normal",new a.BufferAttribute(i,3));let M=null;if(2===e?M=r?new u(h,1===c.length?c[0]:c):new a.LineSegments(h,1===c.length?c[0]:c):3===e&&(M=new a.Mesh(h,1===c.length?c[0]:c)),r){M.isConditionalLine=!0;const e=new Float32Array(6*t.length),r=new Float32Array(6*t.length),n=new Float32Array(6*t.length);for(let a=0,o=t.length;a<o;a++){const o=t[a],i=o.vertices,s=o.controlPoints,l=s[0],c=s[1],u=i[0],d=i[1],h=6*a;e[h+0]=l.x,e[h+1]=l.y,e[h+2]=l.z,e[h+3]=l.x,e[h+4]=l.y,e[h+5]=l.z,r[h+0]=c.x,r[h+1]=c.y,r[h+2]=c.z,r[h+3]=c.x,r[h+4]=c.y,r[h+5]=c.z,n[h+0]=d.x-u.x,n[h+1]=d.y-u.y,n[h+2]=d.z-u.z,n[h+3]=d.x-u.x,n[h+4]=d.y-u.y,n[h+5]=d.z-u.z}h.setAttribute("control0",new a.BufferAttribute(e,3,!1)),h.setAttribute("control1",new a.BufferAttribute(r,3,!1)),h.setAttribute("direction",new a.BufferAttribute(n,3,!1))}return M}class b extends a.Loader{constructor(t){super(t),this.materials=[],this.materialLibrary={},this.partsCache=new f(this),this.fileMap={},this.setMaterials([]),this.smoothNormals=!0,this.partsLibraryPath="",this.missingColorMaterial=new a.MeshStandardMaterial({color:16711935,roughness:.3,metalness:0}),this.missingColorMaterial.name="Missing material",this.missingEdgeColorMaterial=new a.LineBasicMaterial({color:16711935}),this.missingEdgeColorMaterial.name="Missing material - Edge",this.missingConditionalEdgeColorMaterial=new c({fog:!0,color:16711935}),this.missingConditionalEdgeColorMaterial.name="Missing material - Conditional Edge",this.missingColorMaterial.userData.edgeMaterial=this.missingEdgeColorMaterial,this.missingEdgeColorMaterial.userData.conditionalEdgeMaterial=this.missingConditionalEdgeColorMaterial}setPartsLibraryPath(t){return this.partsLibraryPath=t,this}async preloadMaterials(t){const e=new a.FileLoader(this.manager);e.setPath(this.path),e.setRequestHeader(this.requestHeader),e.setWithCredentials(this.withCredentials);const r=/^0 !COLOUR/,n=(await e.loadAsync(t)).split(/[\n\r]/g),o=[];for(let t=0,e=n.length;t<e;t++){const e=n[t];if(r.test(e)){const t=e.replace(r,""),a=this.parseColorMetaDirective(new g(t));o.push(a)}}this.setMaterials(o)}load(t,e,r,n){const i=new a.FileLoader(this.manager);i.setPath(this.path),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials),i.load(t,(r=>{this.partsCache.parseModel(r,this.materialLibrary).then((r=>{this.applyMaterialsToMesh(r,o,this.materialLibrary,!0),this.computeBuildingSteps(r),r.userData.fileName=t,e(r)})).catch(n)}),r,n)}parse(t,e){this.partsCache.parseModel(t,this.materialLibrary).then((t=>{this.applyMaterialsToMesh(t,o,this.materialLibrary,!0),this.computeBuildingSteps(t),t.userData.fileName="",e(t)}))}setMaterials(t){this.materialLibrary={},this.materials=[];for(let e=0,r=t.length;e<r;e++)this.addMaterial(t[e]);return this.addMaterial(this.parseColorMetaDirective(new g("Main_Colour CODE 16 VALUE #FF8080 EDGE #333333"))),this.addMaterial(this.parseColorMetaDirective(new g("Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333"))),this}setFileMap(t){return this.fileMap=t,this}addMaterial(t){const e=this.materialLibrary;return e[t.userData.code]||(this.materials.push(t),e[t.userData.code]=t),this}getMaterial(t){if(t.startsWith("0x2")){const e=t.substring(3);return this.parseColorMetaDirective(new g("Direct_Color_"+e+" CODE -1 VALUE #"+e+" EDGE #"+e))}return this.materialLibrary[t]||null}applyMaterialsToMesh(t,e,r,a=!1){const n=this,s=e===o;function l(t,l){if(s&&!(l in r)&&!a)return l;const c=t.isLineSegments||t.isConditionalLine;(!c&&l===o||c&&l===i)&&(l=e);let u=null;if(l in r)u=r[l];else{if(!a)return l;u=n.getMaterial(l),null===u&&(console.warn(`LDrawLoader: Material properties for code ${l} not available.`),u=n.missingColorMaterial)}return t.isLineSegments&&(u=u.userData.edgeMaterial,t.isConditionalLine&&(u=u.userData.conditionalEdgeMaterial)),u}t.traverse((t=>{if(t.isMesh||t.isLineSegments)if(Array.isArray(t.material))for(let e=0,r=t.material.length;e<r;e++)t.material[e].isMaterial||(t.material[e]=l(t,t.material[e]));else t.material.isMaterial||(t.material=l(t,t.material))}))}getMainMaterial(){return this.getMaterial(o)}getMainEdgeMaterial(){const t=this.getMaterial(i);return t?t.userData.edgeMaterial:null}parseColorMetaDirective(t){let e=null,r=16711935,n=16711935,o=1,i=!1,s=0,l=0,u=null;const d=t.getToken();if(!d)throw new Error('LDrawLoader: Material name was expected after "!COLOUR tag'+t.getLineNumberString()+".");let h=null;for(;h=t.getToken(),h;)if(!p(h))switch(h.toUpperCase()){case"CODE":e=t.getToken();break;case"VALUE":if(r=t.getToken(),r.startsWith("0x"))r="#"+r.substring(2);else if(!r.startsWith("#"))throw new Error("LDrawLoader: Invalid color while parsing material"+t.getLineNumberString()+".");break;case"EDGE":if(n=t.getToken(),n.startsWith("0x"))n="#"+n.substring(2);else if(!n.startsWith("#")){if(u=this.getMaterial(n),!u)throw new Error("LDrawLoader: Invalid edge color while parsing material"+t.getLineNumberString()+".");u=u.userData.edgeMaterial}break;case"ALPHA":if(o=parseInt(t.getToken()),isNaN(o))throw new Error("LDrawLoader: Invalid alpha value in material definition"+t.getLineNumberString()+".");o=Math.max(0,Math.min(1,o/255)),o<1&&(i=!0);break;case"LUMINANCE":if(!p(t.getToken()))throw new Error("LDrawLoader: Invalid luminance value in material definition"+g.getLineNumberString()+".");break;case"CHROME":l=1;break;case"PEARLESCENT":l=2;break;case"RUBBER":l=3;break;case"MATTE_METALLIC":l=4;break;case"METAL":l=5;break;case"MATERIAL":t.setToEnd();break;default:throw new Error('LDrawLoader: Unknown token "'+h+'" while parsing material'+t.getLineNumberString()+".")}let m=null;switch(l){case 0:m=new a.MeshStandardMaterial({color:r,roughness:.3,metalness:0});break;case 2:m=new a.MeshStandardMaterial({color:r,roughness:.3,metalness:.25});break;case 1:m=new a.MeshStandardMaterial({color:r,roughness:0,metalness:1});break;case 3:m=new a.MeshStandardMaterial({color:r,roughness:.9,metalness:0});break;case 4:m=new a.MeshStandardMaterial({color:r,roughness:.8,metalness:.4});break;case 5:m=new a.MeshStandardMaterial({color:r,roughness:.2,metalness:.85})}return m.transparent=i,m.premultipliedAlpha=!0,m.opacity=o,m.depthWrite=!i,m.color.convertSRGBToLinear(),m.polygonOffset=!0,m.polygonOffsetFactor=1,0!==s&&m.emissive.set(m.color).multiplyScalar(s),u||(u=new a.LineBasicMaterial({color:n,transparent:i,opacity:o,depthWrite:!i}),u.userData.code=e,u.name=d+" - Edge",u.color.convertSRGBToLinear(),u.userData.conditionalEdgeMaterial=new c({fog:!0,transparent:i,depthWrite:!i,color:n,opacity:o}),u.userData.conditionalEdgeMaterial.color.convertSRGBToLinear(),u.userData.conditionalEdgeMaterial.userData.code=e,u.userData.conditionalEdgeMaterial.name=d+" - Conditional Edge"),m.userData.code=e,m.name=d,m.userData.edgeMaterial=u,this.addMaterial(m),m;function p(t){let e;return e=t.startsWith("LUMINANCE")?parseInt(t.substring(9)):parseInt(t),!isNaN(e)&&(s=Math.max(0,Math.min(1,e/255)),!0)}}computeBuildingSteps(t){let e=0;t.traverse((t=>{t.isGroup&&(t.userData.startingBuildingStep&&e++,t.userData.buildingStep=e)})),t.userData.numBuildingSteps=e+1}}})),n.register("9hfHi",(function(e,r){t(e.exports,"LDrawUtils",(()=>i));var a=n("ilwiq"),o=n("7ePFa");class i{static mergeObject(t){function e(t,e,r,n){const o=new a.BufferGeometry,i=t.getAttribute("position").array,s=3===r?t.getAttribute("normal").array:null,l=Math.min(e.count,Math.floor(i.length/3)-e.start),c=3*e.start,u=3*(e.start+l),d=i.subarray(c,u),h=null!==s?s.subarray(c,u):null;if(o.setAttribute("position",new a.BufferAttribute(d,3)),null!==h&&o.setAttribute("normal",new a.BufferAttribute(h,3)),n){const e=t.getAttribute("control0").array.subarray(c,u),r=t.getAttribute("control1").array.subarray(c,u),n=t.getAttribute("direction").array.subarray(c,u);o.setAttribute("control0",new a.BufferAttribute(e,3,!1)),o.setAttribute("control1",new a.BufferAttribute(r,3,!1)),o.setAttribute("direction",new a.BufferAttribute(n,3,!1))}return o}function r(t,e,r){const a=r[t.uuid];a?a.arr.push(e):r[t.uuid]={mat:t,arr:[e]}}function n(t,e){if(!t)return;const r=t.array,a=Math.floor(r.length/3);let n=0;for(let t=0;t<a;t++){const t=r[n],a=r[n+1],o=r[n+2];r[n]=r[n+3],r[n+1]=r[n+4],r[n+2]=r[n+5],r[n+3]=t,r[n+4]=a,r[n+5]=o,n+=3*e}}const i={},s={},l={};t.updateMatrixWorld(!0);const c=new a.Matrix3;t.traverse((t=>{if(t.isMesh|t.isLineSegments){const a=t.isMesh?3:2,o=t.geometry.clone();t.matrixWorld.determinant()<0&&(n(o.attributes.position,a),n(o.attributes.normal,a)),o.applyMatrix4(t.matrixWorld),t.isConditionalLine&&(o.attributes.control0.applyMatrix4(t.matrixWorld),o.attributes.control1.applyMatrix4(t.matrixWorld),c.getNormalMatrix(t.matrixWorld),o.attributes.direction.applyNormalMatrix(c));const u=t.isMesh?i:t.isConditionalLine?l:s;if(Array.isArray(t.material))for(const n in o.groups){const i=o.groups[n];r(t.material[i.materialIndex],e(o,i,a,t.isConditionalLine),u)}else r(t.material,o,u)}}));const u=new a.Group,d=Object.keys(i);for(const t of d){const e=i[t],r=o.mergeBufferGeometries(e.arr);u.add(new a.Mesh(r,e.mat))}const h=Object.keys(s);for(const t of h){const e=s[t],r=o.mergeBufferGeometries(e.arr);u.add(new a.LineSegments(r,e.mat))}const g=Object.keys(l);for(const t of g){const e=l[t],r=o.mergeBufferGeometries(e.arr),n=new a.LineSegments(r,e.mat);n.isConditionalLine=!0,u.add(n)}return u.userData.constructionStep=0,u.userData.numConstructionSteps=1,u}}}));
//# sourceMappingURL=index.56e40678.js.map

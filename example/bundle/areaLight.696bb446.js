function t(t,e,n,a){Object.defineProperty(t,e,{get:n,set:a,enumerable:!0,configurable:!0})}var e="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:{},n={},a={},r=e.parcelRequire5b70;null==r&&((r=function(t){if(t in n)return n[t].exports;if(t in a){var e=a[t];delete a[t];var r={id:t,exports:{}};return n[t]=r,e.call(r.exports,r,r.exports),r.exports}var i=new Error("Cannot find module '"+t+"'");throw i.code="MODULE_NOT_FOUND",i}).register=function(t,e){a[t]=e},e.parcelRequire5b70=r),r.register("4CEV9",(function(e,n){t(e.exports,"PathTracingRenderer",(()=>r("hWds8").PathTracingRenderer)),t(e.exports,"QuiltPathTracingRenderer",(()=>r("aOYVY").QuiltPathTracingRenderer)),t(e.exports,"DynamicPathTracingSceneGenerator",(()=>r("lDKrr").DynamicPathTracingSceneGenerator)),t(e.exports,"MaterialReducer",(()=>r("62xhu").MaterialReducer)),t(e.exports,"PhysicalCamera",(()=>r("kLfIo").PhysicalCamera)),t(e.exports,"EquirectCamera",(()=>r("3Npwq").EquirectCamera)),t(e.exports,"PhysicalSpotLight",(()=>r("d4kES").PhysicalSpotLight)),t(e.exports,"ShapedAreaLight",(()=>r("iJGcZ").ShapedAreaLight)),t(e.exports,"GradientEquirectTexture",(()=>r("bHiTZ").GradientEquirectTexture)),t(e.exports,"BlurredEnvMapGenerator",(()=>r("eLX8K").BlurredEnvMapGenerator)),t(e.exports,"IESLoader",(()=>r("77Fts").IESLoader)),t(e.exports,"DenoiseMaterial",(()=>r("8Wcby").DenoiseMaterial)),t(e.exports,"GraphMaterial",(()=>r("1TZNq").GraphMaterial)),t(e.exports,"MaterialBase",(()=>r("9fZ6X").MaterialBase)),t(e.exports,"PhysicalPathTracingMaterial",(()=>r("ieQ3q").PhysicalPathTracingMaterial)),t(e.exports,"FogVolumeMaterial",(()=>r("11ZPe").FogVolumeMaterial)),r("hWds8"),r("aOYVY"),r("lDKrr"),r("62xhu"),r("kLfIo"),r("3Npwq"),r("d4kES"),r("iJGcZ"),r("bHiTZ"),r("eLX8K"),r("77Fts"),r("8Wcby"),r("1TZNq"),r("9fZ6X"),r("ieQ3q"),r("11ZPe")})),r.register("hWds8",(function(e,n){t(e.exports,"PathTracingRenderer",(()=>h));var a=r("ilwiq"),i=r("RPVlj"),o=r("4dqlL"),s=r("9kitj");const l=new a.Vector4,c=new a.Vector4;function*u(){const{_renderer:t,_fsQuad:e,_blendQuad:n,_primaryTarget:r,_blendTargets:i,_sobolTarget:o,_subframe:s,alpha:u,camera:f,material:h}=this,m=new a.Vector4,d=new a.Vector4,p=n.material;let[g,v]=i;for(;;){u?(p.opacity=this._opacityFactor/(this._samples+1),h.blending=a.NoBlending,h.opacity=1):(h.opacity=this._opacityFactor/(this._samples+1),h.blending=a.NormalBlending);const[i,x,y,b]=s,T=r.width,S=r.height;h.resolution.set(T*y,S*b),h.sobolTexture=o.texture,h.seed++;const w=this.tiles.x||1,R=this.tiles.y||1,F=w*R,D=1/t.getPixelRatio();for(let a=0;a<R;a++)for(let o=0;o<w;o++){h.cameraWorldMatrix.copy(f.matrixWorld),h.invProjectionMatrix.copy(f.projectionMatrixInverse);let s=0;f.projectionMatrix.elements[15]>0&&(s=1),f.isEquirectCamera&&(s=2),h.setDefine("CAMERA_TYPE",s);const C=t.getRenderTarget(),I=t.autoClear,P=t.getScissorTest();t.getScissor(m),t.getViewport(d);let M=o,_=a;if(!this.stableTiles){const t=this._currentTile%(w*R);M=t%w,_=~~(t/w),this._currentTile=t+1}t.setRenderTarget(r),t.setScissorTest(!0),l.x=M*T/w,l.y=(R-_-1)*S/R,l.z=T/w,l.w=S/R,l.x=i*T+y*l.x,l.y=x*S+b*l.y,l.z=y*l.z,l.w=b*l.w,l.x=l.x,l.y=l.y,l.z=l.z,l.w=l.w,l.multiplyScalar(D).ceil(),c.x=i*T,c.y=x*S,c.z=y*T,c.w=b*S,c.multiplyScalar(D).ceil(),t.setScissor(l),t.setViewport(c),t.autoClear=!1,e.render(t),t.setViewport(d),t.setScissor(m),t.setScissorTest(P),t.setRenderTarget(C),t.autoClear=I,u&&(p.target1=g.texture,p.target2=r.texture,t.setRenderTarget(v),n.render(t),t.setRenderTarget(C)),this._samples+=1/F,o===w-1&&a===R-1&&(this._samples=Math.round(this._samples)),yield}[g,v]=[v,g]}}const f=new a.Color;class h{get material(){return this._fsQuad.material}set material(t){this._fsQuad.material=t}get target(){return this._alpha?this._blendTargets[1]:this._primaryTarget}set alpha(t){this._alpha!==t&&(t||(this._blendTargets[0].dispose(),this._blendTargets[1].dispose()),this._alpha=t,this.reset())}get alpha(){return this._alpha}get samples(){return this._samples}constructor(t){this.camera=null,this.tiles=new a.Vector2(1,1),this.stableNoise=!1,this.stableTiles=!0,this._samples=0,this._subframe=new a.Vector4(0,0,1,1),this._opacityFactor=1,this._renderer=t,this._alpha=!1,this._fsQuad=new i.FullScreenQuad(null),this._blendQuad=new i.FullScreenQuad(new o.BlendMaterial),this._task=null,this._currentTile=0,this._sobolTarget=(new s.SobolNumberMapGenerator).generate(t),this._primaryTarget=new a.WebGLRenderTarget(1,1,{format:a.RGBAFormat,type:a.FloatType}),this._blendTargets=[new a.WebGLRenderTarget(1,1,{format:a.RGBAFormat,type:a.FloatType}),new a.WebGLRenderTarget(1,1,{format:a.RGBAFormat,type:a.FloatType})]}setSize(t,e){t=Math.ceil(t),e=Math.ceil(e),this._primaryTarget.width===t&&this._primaryTarget.height===e||(this._primaryTarget.setSize(t,e),this._blendTargets[0].setSize(t,e),this._blendTargets[1].setSize(t,e),this.reset())}dispose(){this._primaryTarget.dispose(),this._blendTargets[0].dispose(),this._blendTargets[1].dispose(),this._sobolTarget.dispose(),this._fsQuad.dispose(),this._blendQuad.dispose(),this._task=null}reset(){const{_renderer:t,_primaryTarget:e,_blendTargets:n}=this,a=t.getRenderTarget(),r=t.getClearAlpha();t.getClearColor(f),t.setRenderTarget(e),t.setClearColor(0,0),t.clearColor(),t.setRenderTarget(n[0]),t.setClearColor(0,0),t.clearColor(),t.setRenderTarget(n[1]),t.setClearColor(0,0),t.clearColor(),t.setClearColor(f,r),t.setRenderTarget(a),this._samples=0,this._task=null,this.stableNoise&&(this.material.seed=0)}update(){this._task||(this._task=u.call(this)),this._task.next()}}})),r.register("4dqlL",(function(e,n){t(e.exports,"BlendMaterial",(()=>o));var a=r("ilwiq"),i=r("9fZ6X");class o extends i.MaterialBase{constructor(t){super({blending:a.NoBlending,uniforms:{target1:{value:null},target2:{value:null},opacity:{value:1}},vertexShader:"\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}",fragmentShader:"\n\n\t\t\t\tuniform float opacity;\n\n\t\t\t\tuniform sampler2D target1;\n\t\t\t\tuniform sampler2D target2;\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 color1 = texture2D( target1, vUv );\n\t\t\t\t\tvec4 color2 = texture2D( target2, vUv );\n\n\t\t\t\t\tfloat invOpacity = 1.0 - opacity;\n\t\t\t\t\tfloat totalAlpha = color1.a * invOpacity + color2.a * opacity;\n\n\t\t\t\t\tif ( color1.a != 0.0 || color2.a != 0.0 ) {\n\n\t\t\t\t\t\tgl_FragColor.rgb = color1.rgb * ( invOpacity * color1.a / totalAlpha ) + color2.rgb * ( opacity * color2.a / totalAlpha );\n\t\t\t\t\t\tgl_FragColor.a = totalAlpha;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl_FragColor = vec4( 0.0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}"}),this.setValues(t)}}})),r.register("9kitj",(function(e,n){t(e.exports,"SobolNumberMapGenerator",(()=>c));var a=r("ilwiq"),i=r("RPVlj"),o=r("9fZ6X"),s=r("ffLvN");class l extends o.MaterialBase{constructor(){super({blending:a.NoBlending,uniforms:{resolution:{value:new a.Vector2}},vertexShader:"\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\t\t\t",fragmentShader:`\n\n\t\t\t\t${s.sobolCommonGLSL}\n\t\t\t\t${s.sobolGenerationGLSL}\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform vec2 resolution;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tuint index = uint( gl_FragCoord.y ) * uint( resolution.x ) + uint( gl_FragCoord.x );\n\t\t\t\t\tgl_FragColor = generateSobolPoint( index );\n\n\t\t\t\t}\n\t\t\t`})}}class c{generate(t,e=256){const n=new a.WebGLRenderTarget(e,e,{type:a.FloatType,format:a.RGBAFormat,minFilter:a.NearestFilter,magFilter:a.NearestFilter,generateMipmaps:!1}),r=t.getRenderTarget();t.setRenderTarget(n);const o=new i.FullScreenQuad(new l);return o.material.resolution.set(e,e),o.render(t),t.setRenderTarget(r),o.dispose(),n}}})),r.register("ffLvN",(function(e,n){function a(t=1){let e="uint";return t>1&&(e="uvec"+t),`\n\t\t${e} sobolReverseBits( ${e} x ) {\n\n\t\t\tx = ( ( ( x & 0xaaaaaaaau ) >> 1 ) | ( ( x & 0x55555555u ) << 1 ) );\n\t\t\tx = ( ( ( x & 0xccccccccu ) >> 2 ) | ( ( x & 0x33333333u ) << 2 ) );\n\t\t\tx = ( ( ( x & 0xf0f0f0f0u ) >> 4 ) | ( ( x & 0x0f0f0f0fu ) << 4 ) );\n\t\t\tx = ( ( ( x & 0xff00ff00u ) >> 8 ) | ( ( x & 0x00ff00ffu ) << 8 ) );\n\t\t\treturn ( ( x >> 16 ) | ( x << 16 ) );\n\n\t\t}\n\n\t\t${e} sobolHashCombine( uint seed, ${e} v ) {\n\n\t\t\treturn seed ^ ( v + ${e}( ( seed << 6 ) + ( seed >> 2 ) ) );\n\n\t\t}\n\n\t\t${e} sobolLaineKarrasPermutation( ${e} x, ${e} seed ) {\n\n\t\t\tx += seed;\n\t\t\tx ^= x * 0x6c50b47cu;\n\t\t\tx ^= x * 0xb82f1e52u;\n\t\t\tx ^= x * 0xc7afe638u;\n\t\t\tx ^= x * 0x8d22f6e6u;\n\t\t\treturn x;\n\n\t\t}\n\n\t\t${e} nestedUniformScrambleBase2( ${e} x, ${e} seed ) {\n\n\t\t\tx = sobolLaineKarrasPermutation( x, seed );\n\t\t\tx = sobolReverseBits( x );\n\t\t\treturn x;\n\n\t\t}\n\t`}function r(t=1){let e="uint",n="float",a="",r=".r",i="1u";return t>1&&(e="uvec"+t,n="vec"+t,a=t+"",2===t?(r=".rg",i="uvec2( 1u, 2u )"):3===t?(r=".rgb",i="uvec3( 1u, 2u, 3u )"):(r="",i="uvec4( 1u, 2u, 3u, 4u )")),`\n\n\t\t${n} sobol${a}( int effect ) {\n\n\t\t\tuint seed = sobolGetSeed( sobolBounceIndex, uint( effect ) );\n\t\t\tuint index = sobolPathIndex;\n\n\t\t\tuint shuffle_seed = sobolHashCombine( seed, 0u );\n\t\t\tuint shuffled_index = nestedUniformScrambleBase2( sobolReverseBits( index ), shuffle_seed );\n\t\t\t${n} sobol_pt = sobolGetTexturePoint( shuffled_index )${r};\n\t\t\t${e} result = ${e}( sobol_pt * 16777216.0 );\n\n\t\t\t${e} seed2 = sobolHashCombine( seed, ${i} );\n\t\t\tresult = nestedUniformScrambleBase2( result, seed2 );\n\n\t\t\treturn SOBOL_FACTOR * ${n}( result >> 8 );\n\n\t\t}\n\t`}t(e.exports,"sobolCommonGLSL",(()=>i)),t(e.exports,"sobolGenerationGLSL",(()=>o)),t(e.exports,"sobolSamplingGLSL",(()=>s));const i=`\n\n\t// Utils\n\tconst float SOBOL_FACTOR = 1.0 / 16777216.0;\n\tconst uint SOBOL_MAX_POINTS = 256u * 256u;\n\n\t${a(1)}\n\t${a(2)}\n\t${a(3)}\n\t${a(4)}\n\n\tuint sobolHash( uint x ) {\n\n\t\t// finalizer from murmurhash3\n\t\tx ^= x >> 16;\n\t\tx *= 0x85ebca6bu;\n\t\tx ^= x >> 13;\n\t\tx *= 0xc2b2ae35u;\n\t\tx ^= x >> 16;\n\t\treturn x;\n\n\t}\n\n`,o='\n\n\tconst uint SOBOL_DIRECTIONS_1[ 32 ] = uint[ 32 ](\n\t\t0x80000000u, 0xc0000000u, 0xa0000000u, 0xf0000000u,\n\t\t0x88000000u, 0xcc000000u, 0xaa000000u, 0xff000000u,\n\t\t0x80800000u, 0xc0c00000u, 0xa0a00000u, 0xf0f00000u,\n\t\t0x88880000u, 0xcccc0000u, 0xaaaa0000u, 0xffff0000u,\n\t\t0x80008000u, 0xc000c000u, 0xa000a000u, 0xf000f000u,\n\t\t0x88008800u, 0xcc00cc00u, 0xaa00aa00u, 0xff00ff00u,\n\t\t0x80808080u, 0xc0c0c0c0u, 0xa0a0a0a0u, 0xf0f0f0f0u,\n\t\t0x88888888u, 0xccccccccu, 0xaaaaaaaau, 0xffffffffu\n\t);\n\n\tconst uint SOBOL_DIRECTIONS_2[ 32 ] = uint[ 32 ](\n\t\t0x80000000u, 0xc0000000u, 0x60000000u, 0x90000000u,\n\t\t0xe8000000u, 0x5c000000u, 0x8e000000u, 0xc5000000u,\n\t\t0x68800000u, 0x9cc00000u, 0xee600000u, 0x55900000u,\n\t\t0x80680000u, 0xc09c0000u, 0x60ee0000u, 0x90550000u,\n\t\t0xe8808000u, 0x5cc0c000u, 0x8e606000u, 0xc5909000u,\n\t\t0x6868e800u, 0x9c9c5c00u, 0xeeee8e00u, 0x5555c500u,\n\t\t0x8000e880u, 0xc0005cc0u, 0x60008e60u, 0x9000c590u,\n\t\t0xe8006868u, 0x5c009c9cu, 0x8e00eeeeu, 0xc5005555u\n\t);\n\n\tconst uint SOBOL_DIRECTIONS_3[ 32 ] = uint[ 32 ](\n\t\t0x80000000u, 0xc0000000u, 0x20000000u, 0x50000000u,\n\t\t0xf8000000u, 0x74000000u, 0xa2000000u, 0x93000000u,\n\t\t0xd8800000u, 0x25400000u, 0x59e00000u, 0xe6d00000u,\n\t\t0x78080000u, 0xb40c0000u, 0x82020000u, 0xc3050000u,\n\t\t0x208f8000u, 0x51474000u, 0xfbea2000u, 0x75d93000u,\n\t\t0xa0858800u, 0x914e5400u, 0xdbe79e00u, 0x25db6d00u,\n\t\t0x58800080u, 0xe54000c0u, 0x79e00020u, 0xb6d00050u,\n\t\t0x800800f8u, 0xc00c0074u, 0x200200a2u, 0x50050093u\n\t);\n\n\tconst uint SOBOL_DIRECTIONS_4[ 32 ] = uint[ 32 ](\n\t\t0x80000000u, 0x40000000u, 0x20000000u, 0xb0000000u,\n\t\t0xf8000000u, 0xdc000000u, 0x7a000000u, 0x9d000000u,\n\t\t0x5a800000u, 0x2fc00000u, 0xa1600000u, 0xf0b00000u,\n\t\t0xda880000u, 0x6fc40000u, 0x81620000u, 0x40bb0000u,\n\t\t0x22878000u, 0xb3c9c000u, 0xfb65a000u, 0xddb2d000u,\n\t\t0x78022800u, 0x9c0b3c00u, 0x5a0fb600u, 0x2d0ddb00u,\n\t\t0xa2878080u, 0xf3c9c040u, 0xdb65a020u, 0x6db2d0b0u,\n\t\t0x800228f8u, 0x400b3cdcu, 0x200fb67au, 0xb00ddb9du\n\t);\n\n\tuint getMaskedSobol( uint index, uint directions[ 32 ] ) {\n\n\t\tuint X = 0u;\n\t\tfor ( int bit = 0; bit < 32; bit ++ ) {\n\n\t\t\tuint mask = ( index >> bit ) & 1u;\n\t\t\tX ^= mask * directions[ bit ];\n\n\t\t}\n\t\treturn X;\n\n\t}\n\n\tvec4 generateSobolPoint( uint index ) {\n\n\t\tif ( index >= SOBOL_MAX_POINTS ) {\n\n\t\t\treturn vec4( 0.0 );\n\n\t\t}\n\n\t\t// NOTEL this sobol "direction" is also available but we can\'t write out 5 components\n\t\t// uint x = index & 0x00ffffffu;\n\t\tuint x = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_1 ) ) & 0x00ffffffu;\n\t\tuint y = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_2 ) ) & 0x00ffffffu;\n\t\tuint z = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_3 ) ) & 0x00ffffffu;\n\t\tuint w = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_4 ) ) & 0x00ffffffu;\n\n\t\treturn vec4( x, y, z, w ) * SOBOL_FACTOR;\n\n\t}\n\n',s=`\n\n\t// Seeds\n\tuniform sampler2D sobolTexture;\n\tuint sobolPixelIndex;\n\tuint sobolPathIndex;\n\tuint sobolBounceIndex;\n\n\tuint sobolGetSeed( uint bounce, uint effect ) {\n\n\t\treturn sobolHash(\n\t\t\tsobolHashCombine(\n\t\t\t\tsobolHashCombine(\n\t\t\t\t\tsobolHash( bounce ),\n\t\t\t\t\tsobolPixelIndex\n\t\t\t\t),\n\t\t\t\teffect\n\t\t\t)\n\t\t);\n\n\t}\n\n\tvec4 sobolGetTexturePoint( uint index ) {\n\n\t\tif ( index >= SOBOL_MAX_POINTS ) {\n\n\t\t\tindex = index % SOBOL_MAX_POINTS;\n\n\t\t}\n\n\t\tuvec2 dim = uvec2( textureSize( sobolTexture, 0 ).xy );\n\t\tuint y = index / dim.x;\n\t\tuint x = index - y * dim.x;\n\t\tvec2 uv = vec2( x, y ) / vec2( dim );\n\t\treturn texture( sobolTexture, uv );\n\n\t}\n\n\t${r(1)}\n\t${r(2)}\n\t${r(3)}\n\t${r(4)}\n\n`})),r.register("aOYVY",(function(e,n){t(e.exports,"QuiltPathTracingRenderer",(()=>l));var a=r("ilwiq"),i=r("hWds8");function*o(t){const{viewCount:e,_camera:n,_quiltUtility:r,_subframe:i}=this,o={subframe:i,projectionMatrix:n.projectionMatrix,offsetDirection:new a.Vector3};for(;;){for(let a=0;a<e;a++){r.near=this.camera.near,r.far=this.camera.far,r.getCameraViewInfo(a,o),o.offsetDirection.transformDirection(this.camera.matrixWorld),this.camera.matrixWorld.decompose(n.position,n.quaternion,n.scale),n.position.addScaledVector(o.offsetDirection,o.offset),n.updateMatrixWorld(),n.projectionMatrixInverse.copy(n.projectionMatrix).invert(),this._opacityFactor=Math.floor(this._samples+1)/Math.floor(this._quiltSamples+1);do{const e=this.camera;this.camera=n,t(),this.camera=e,yield}while(this._samples%1!=0);this._quiltSamples+=1/e}this._quiltSamples=Math.round(this._quiltSamples)}}class s{constructor(){this.viewCount=48,this.quiltDimensions=new a.Vector2(8,6),this.viewCone=35*a.MathUtils.DEG2RAD,this.viewFoV=14*a.MathUtils.DEG2RAD,this.displayDistance=1,this.displayAspect=.75,this.near=.01,this.far=10}getCameraViewInfo(t,e={}){const{quiltDimensions:n,viewCone:r,displayDistance:i,viewCount:o,viewFoV:s,displayAspect:l,near:c,far:u}=this;e.subframe=e.subframe||new a.Vector4,e.offsetDirection=e.offsetDirection||new a.Vector3,e.projectionMatrix=e.projectionMatrix||new a.Matrix4;const f=Math.tan(.5*r)*i,h=1===o?0:2*f/(o-1)*t-f;e.offsetDirection.set(1,0,0),e.offset=h;const m=Math.tan(.5*s)*i,d=l*m,p=c/i;e.projectionMatrix.makePerspective(p*(-d-h),p*(d-h),p*m,p*-m,c,u);const g=t%n.x,v=Math.floor(t/n.x),x=1/n.x,y=1/n.y;return e.subframe.set(g*x,v*y,x,y),e}setFromDisplayView(t,e,n){this.displayAspect=e/n,this.displayDistance=t,this.viewFoV=2*Math.atan(.5*n/t)}}class l extends i.PathTracingRenderer{get samples(){return this._samples/this.viewCount}constructor(...t){super(...t),["quiltDimensions","viewCount","viewCone","viewFoV","displayDistance","displayAspect"].forEach((t=>{Object.defineProperty(this,t,{enumerable:!0,set:e=>{this._quiltUtility[t]=e},get:()=>this._quiltUtility[t]})})),this._quiltUtility=new s,this._quiltSamples=0,this._camera=new a.PerspectiveCamera,this._quiltTask=null}setFromDisplayView(...t){this._quiltUtility.setFromDisplayView(...t)}update(){this.alpha=!1,this._quiltTask||(this._quiltTask=o.call(this,(()=>{super.update()}))),this._quiltTask.next()}reset(){super.reset(),this._quiltTask=null,this._quiltSamples=0}}})),r.register("lDKrr",(function(e,n){t(e.exports,"DynamicPathTracingSceneGenerator",(()=>s));var a=r("ilwiq"),i=r("8Zfx2"),o=r("jM3IF");class s{get initialized(){return Boolean(this.bvh)}constructor(t){this.objects=Array.isArray(t)?t:[t],this.bvh=null,this.geometry=new a.BufferGeometry,this.materials=null,this.textures=null,this.lights=[],this.staticGeometryGenerator=new i.StaticGeometryGenerator(this.objects)}reset(){this.bvh=null,this.geometry.dispose(),this.geometry=new a.BufferGeometry,this.materials=null,this.textures=null,this.lights=[],this.staticGeometryGenerator=new i.StaticGeometryGenerator(this.objects)}dispose(){}generate(){const{objects:t,staticGeometryGenerator:e,geometry:n}=this;if(null===this.bvh){const a=["position","normal","tangent","uv","color"];for(let e=0,n=t.length;e<n;e++)t[e].traverse((t=>{if(t.isMesh){const e=!!t.material.normalMap;o.setCommonAttributes(t.geometry,{attributes:a,normalMapRequired:e})}else(t.isRectAreaLight||t.isSpotLight)&&this.lights.push(t)}));const r=new Set,s=e.getMaterials();s.forEach((t=>{for(const e in t){const n=t[e];n&&n.isTexture&&r.add(n)}})),e.attributes=a,e.generate(n);const l=o.getGroupMaterialIndicesAttribute(n,s,s);return n.setAttribute("materialIndex",l),n.clearGroups(),this.bvh=new i.MeshBVH(n),this.materials=s,this.textures=Array.from(r),{lights:this.lights,bvh:this.bvh,materials:this.materials,textures:this.textures,objects:t}}{const{bvh:a}=this;return e.generate(n),a.refit(),{lights:this.lights,bvh:this.bvh,materials:this.materials,textures:this.textures,objects:t}}}}})),r.register("62xhu",(function(e,n){function a(t){return t.buffer instanceof ArrayBuffer&&"BYTES_PER_ELEMENT"in t}t(e.exports,"MaterialReducer",(()=>r));class r{constructor(){const t=new Set;t.add("uuid"),this.ignoreKeys=t,this.shareTextures=!0,this.textures=[],this.materials=[]}areEqual(t,e){const n=new Set,r=new Set,i=this.ignoreKeys,o=(t,e)=>{if(t===e)return!0;if(t&&e&&t instanceof Object&&e instanceof Object){if(r.has(t)||r.has(e))throw new Error("MaterialReducer: Material is recursive.");const s=t instanceof Element,l=e instanceof Element;if(s||l)return s===l&&t instanceof Image&&e instanceof Image&&t.src===e.src;const c=t instanceof ImageBitmap,u=e instanceof ImageBitmap;if(c||u)return!1;if(t.equals)return t.equals(e);const f=a(t),h=a(e);if(f||h){if(f!==h||t.constructor!==e.constructor||t.length!==e.length)return!1;for(let n=0,a=t.length;n<a;n++)if(t[n]!==e[n])return!1;return!0}r.add(t),r.add(e),n.clear();for(const e in t)!t.hasOwnProperty(e)||t[e]instanceof Function||i.has(e)||n.add(e);for(const t in e)!e.hasOwnProperty(t)||e[t]instanceof Function||i.has(t)||n.add(t);const m=Array.from(n.values());let d=!0;for(const n in m){const a=m[n];if(!i.has(a)&&(d=o(t[a],e[a]),!d))break}return r.delete(t),r.delete(e),d}return!1};return o(t,e)}process(t){const{textures:e,materials:n}=this;let a=0;const r=t=>{let r=null;for(const e in n){const a=n[e];this.areEqual(t,a)&&(r=a)}if(r)return a++,r;if(n.push(t),this.shareTextures)for(const n in t){if(!t.hasOwnProperty(n))continue;const a=t[n];if(a&&a.isTexture&&a.image instanceof Image){let r=null;for(const t in e){const n=e[t];if(this.areEqual(n,a)){r=n;break}}r?t[n]=r:e.push(a)}}return t};return t.traverse((t=>{if(t.isMesh&&t.material){const e=t.material;if(Array.isArray(e))for(let t=0;t<e.length;t++)e[t]=r(e[t]);else t.material=r(e)}})),{replaced:a,retained:n.length}}}})),r.register("kLfIo",(function(e,n){t(e.exports,"PhysicalCamera",(()=>i));var a=r("ilwiq");class i extends a.PerspectiveCamera{set bokehSize(t){this.fStop=this.getFocalLength()/t}get bokehSize(){return this.getFocalLength()/this.fStop}constructor(...t){super(...t),this.fStop=1.4,this.apertureBlades=0,this.apertureRotation=0,this.focusDistance=25,this.anamorphicRatio=1}}})),r.register("3Npwq",(function(e,n){t(e.exports,"EquirectCamera",(()=>i));var a=r("ilwiq");class i extends a.Camera{constructor(){super(),this.isEquirectCamera=!0}}})),r.register("d4kES",(function(e,n){t(e.exports,"PhysicalSpotLight",(()=>i));var a=r("ilwiq");class i extends a.SpotLight{constructor(...t){super(...t),this.iesTexture=null,this.radius=0}}})),r.register("iJGcZ",(function(e,n){t(e.exports,"ShapedAreaLight",(()=>i));var a=r("ilwiq");class i extends a.RectAreaLight{constructor(...t){super(...t),this.isCircular=!1}}})),r.register("bHiTZ",(function(e,n){t(e.exports,"GradientEquirectTexture",(()=>s));var a=r("ilwiq"),i=r("dbdMq");const o=new a.Vector3;class s extends i.ProceduralEquirectTexture{constructor(t=512){super(t,t),this.topColor=(new a.Color).set(16777215),this.bottomColor=(new a.Color).set(0),this.exponent=2,this.generationCallback=(t,e,n,a)=>{o.setFromSpherical(t);const r=.5*o.y+.5;a.lerpColors(this.bottomColor,this.topColor,r**this.exponent)}}copy(t){return super.copy(t),this.topColor.copy(t.topColor),this.bottomColor.copy(t.bottomColor),this}}})),r.register("dbdMq",(function(e,n){t(e.exports,"ProceduralEquirectTexture",(()=>c));var a=r("ilwiq");const i=new a.Vector2,o=new a.Vector2,s=new a.Spherical,l=new a.Color;class c extends a.DataTexture{constructor(t,e){super(new Float32Array(t*e*4),t,e,a.RGBAFormat,a.FloatType,a.EquirectangularReflectionMapping,a.RepeatWrapping,a.ClampToEdgeWrapping,a.LinearFilter,a.LinearFilter),this.generationCallback=null}update(){this.dispose(),this.needsUpdate=!0;const{data:t,width:e,height:n}=this.image;for(let a=0;a<e;a++)for(let r=0;r<n;r++){o.set(e,n),i.set(a/e,r/n),i.x-=.5,i.y=1-i.y,s.theta=2*i.x*Math.PI,s.phi=i.y*Math.PI,s.radius=1,this.generationCallback(s,i,o,l);const c=4*(r*e+a);t[c+0]=l.r,t[c+1]=l.g,t[c+2]=l.b,t[c+3]=1}}copy(t){return super.copy(t),this.generationCallback=t.generationCallback,this}}})),r.register("eLX8K",(function(e,n){t(e.exports,"BlurredEnvMapGenerator",(()=>c));var a=r("ilwiq"),i=r("RPVlj"),o=r("9fZ6X"),s=r("6T5Sj");class l extends o.MaterialBase{constructor(){super({uniforms:{envMap:{value:null},blur:{value:0}},vertexShader:"\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}\n\n\t\t\t",fragmentShader:`\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\t\t${s.utilsGLSL}\n\n\t\t\t\tuniform sampler2D envMap;\n\t\t\t\tuniform float blur;\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 rayDirection = equirectUvToDirection( vUv );\n\t\t\t\t\tgl_FragColor = textureCubeUV( envMap, rayDirection, blur );\n\n\t\t\t\t}\n\n\t\t\t`})}}class c{constructor(t){this.renderer=t,this.pmremGenerator=new a.PMREMGenerator(t),this.copyQuad=new i.FullScreenQuad(new l),this.renderTarget=new a.WebGLRenderTarget(1,1,{type:a.FloatType,format:a.RGBAFormat})}dispose(){this.pmremGenerator.dispose(),this.copyQuad.dispose(),this.renderTarget.dispose()}generate(t,e){const{pmremGenerator:n,renderTarget:r,copyQuad:i,renderer:o}=this,s=n.fromEquirectangular(t),{width:l,height:c}=t.image;r.setSize(l,c),i.material.envMap=s.texture,i.material.blur=e;const u=o.getRenderTarget(),f=o.autoClear;o.setRenderTarget(r),o.autoClear=!0,i.render(o),o.setRenderTarget(u),o.autoClear=f;const h=new Float32Array(l*c*4);o.readRenderTargetPixels(r,0,0,l,c,h);const m=new a.DataTexture(h,l,c,a.RGBAFormat,a.FloatType);return m.minFilter=t.minFilter,m.magFilter=t.magFilter,m.wrapS=t.wrapS,m.wrapT=t.wrapT,m.mapping=a.EquirectangularReflectionMapping,m.needsUpdate=!0,s.dispose(),m}}})),r.register("6T5Sj",(function(e,n){t(e.exports,"utilsGLSL",(()=>a));const a="\n\n\t// TODO: possibly this should be renamed something related to material or path tracing logic\n\n\t#ifndef RAY_OFFSET\n\t#define RAY_OFFSET 1e-4\n\t#endif\n\n\t// adjust the hit point by the surface normal by a factor of some offset and the\n\t// maximum component-wise value of the current point to accommodate floating point\n\t// error as values increase.\n\tvec3 stepRayOrigin( vec3 rayOrigin, vec3 rayDirection, vec3 offset, float dist ) {\n\n\t\tvec3 point = rayOrigin + rayDirection * dist;\n\t\tvec3 absPoint = abs( point );\n\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\n\t\treturn point + offset * ( maxPoint + 1.0 ) * RAY_OFFSET;\n\n\t}\n\n\t// https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#attenuation\n\tvec3 transmissionAttenuation( float dist, vec3 attColor, float attDist ) {\n\n\t\tvec3 ot = - log( attColor ) / attDist;\n\t\treturn exp( - ot * dist );\n\n\t}\n\n\tvec3 getHalfVector( vec3 wi, vec3 wo, float eta ) {\n\n\t\t// get the half vector - assuming if the light incident vector is on the other side\n\t\t// of the that it's transmissive.\n\t\tvec3 h;\n\t\tif ( wi.z > 0.0 ) {\n\n\t\t\th = normalize( wi + wo );\n\n\t\t} else {\n\n\t\t\t// Scale by the ior ratio to retrieve the appropriate half vector\n\t\t\t// From Section 2.2 on computing the transmission half vector:\n\t\t\t// https://blog.selfshadow.com/publications/s2015-shading-course/burley/s2015_pbs_disney_bsdf_notes.pdf\n\t\t\th = normalize( wi + wo * eta );\n\n\t\t}\n\n\t\th *= sign( h.z );\n\t\treturn h;\n\n\t}\n\n\tvec3 getHalfVector( vec3 a, vec3 b ) {\n\n\t\treturn normalize( a + b );\n\n\t}\n\n\t// The discrepancy between interpolated surface normal and geometry normal can cause issues when a ray\n\t// is cast that is on the top side of the geometry normal plane but below the surface normal plane. If\n\t// we find a ray like that we ignore it to avoid artifacts.\n\t// This function returns if the direction is on the same side of both planes.\n\tbool isDirectionValid( vec3 direction, vec3 surfaceNormal, vec3 geometryNormal ) {\n\n\t\tbool aboveSurfaceNormal = dot( direction, surfaceNormal ) > 0.0;\n\t\tbool aboveGeometryNormal = dot( direction, geometryNormal ) > 0.0;\n\t\treturn aboveSurfaceNormal == aboveGeometryNormal;\n\n\t}\n\n\t// ray sampling x and z are swapped to align with expected background view\n\tvec2 equirectDirectionToUv( vec3 direction ) {\n\n\t\t// from Spherical.setFromCartesianCoords\n\t\tvec2 uv = vec2( atan( direction.z, direction.x ), acos( direction.y ) );\n\t\tuv /= vec2( 2.0 * PI, PI );\n\n\t\t// apply adjustments to get values in range [0, 1] and y right side up\n\t\tuv.x += 0.5;\n\t\tuv.y = 1.0 - uv.y;\n\t\treturn uv;\n\n\t}\n\n\tvec3 equirectUvToDirection( vec2 uv ) {\n\n\t\t// undo above adjustments\n\t\tuv.x -= 0.5;\n\t\tuv.y = 1.0 - uv.y;\n\n\t\t// from Vector3.setFromSphericalCoords\n\t\tfloat theta = uv.x * 2.0 * PI;\n\t\tfloat phi = uv.y * PI;\n\n\t\tfloat sinPhi = sin( phi );\n\n\t\treturn vec3( sinPhi * cos( theta ), cos( phi ), sinPhi * sin( theta ) );\n\n\t}\n\n\t// power heuristic for multiple importance sampling\n\tfloat misHeuristic( float a, float b ) {\n\n\t\tfloat aa = a * a;\n\t\tfloat bb = b * b;\n\t\treturn aa / ( aa + bb );\n\n\t}\n\n\t// tentFilter from Peter Shirley's 'Realistic Ray Tracing (2nd Edition)' book, pg. 60\n\t// erichlof/THREE.js-PathTracing-Renderer/\n\tfloat tentFilter( float x ) {\n\n\t\treturn x < 0.5 ? sqrt( 2.0 * x ) - 1.0 : 1.0 - sqrt( 2.0 - ( 2.0 * x ) );\n\n\t}\n"})),r.register("77Fts",(function(e,n){t(e.exports,"IESLoader",(()=>o));var a=r("ilwiq");function i(t){const e=this,n=t.split("\n");let a,r=0;function i(t){return(t=(t=(t=t.trim()).replace(/,/g," ")).replace(/\s\s+/g," ")).split(" ")}function o(t,e){for(;;){const a=i(n[r++]);for(let t=0;t<a.length;++t)e.push(Number(a[t]));if(e.length===t)break}}for(e.verAngles=[],e.horAngles=[],e.candelaValues=[],e.tiltData={},e.tiltData.angles=[],e.tiltData.mulFactors=[];a=n[r++],!a.includes("TILT"););a.includes("NONE")||a.includes("INCLUDE")&&function(){let t=n[r++],a=i(t);e.tiltData.lampToLumGeometry=Number(a[0]),t=n[r++],a=i(t),e.tiltData.numAngles=Number(a[0]),o(e.tiltData.numAngles,e.tiltData.angles),o(e.tiltData.numAngles,e.tiltData.mulFactors)}(),function(){const t=[];o(10,t),e.count=Number(t[0]),e.lumens=Number(t[1]),e.multiplier=Number(t[2]),e.numVerAngles=Number(t[3]),e.numHorAngles=Number(t[4]),e.gonioType=Number(t[5]),e.units=Number(t[6]),e.width=Number(t[7]),e.length=Number(t[8]),e.height=Number(t[9])}(),function(){const t=[];o(3,t),e.ballFactor=Number(t[0]),e.blpFactor=Number(t[1]),e.inputWatts=Number(t[2])}();for(let t=0;t<e.numHorAngles;++t)e.candelaValues.push([]);o(e.numVerAngles,e.verAngles),o(e.numHorAngles,e.horAngles);for(let t=0;t<e.numHorAngles;++t)o(e.numVerAngles,e.candelaValues[t]);for(let t=0;t<e.numHorAngles;++t)for(let n=0;n<e.numVerAngles;++n)e.candelaValues[t][n]*=e.candelaValues[t][n]*e.multiplier*e.ballFactor*e.blpFactor;let s=-1;for(let t=0;t<e.numHorAngles;++t)for(let n=0;n<e.numVerAngles;++n){const a=e.candelaValues[t][n];s=s<a?a:s}if(s>0)for(let t=0;t<e.numHorAngles;++t)for(let n=0;n<e.numVerAngles;++n)e.candelaValues[t][n]/=s}class o extends a.Loader{_getIESValues(t){const e=new Float32Array(64800);function n(e,n){let r=0,i=0,o=0,s=0,l=0,c=0;for(let e=0;e<t.numHorAngles-1;++e)if(n<t.horAngles[e+1]||e==t.numHorAngles-2){i=e,o=t.horAngles[e],s=t.horAngles[e+1];break}for(let n=0;n<t.numVerAngles-1;++n)if(e<t.verAngles[n+1]||n==t.numVerAngles-2){r=n,l=t.verAngles[n],c=t.verAngles[n+1];break}const u=s-o,f=c-l;if(0===f)return 0;const h=0===u?0:(n-o)/u,m=(e-l)/f,d=0===u?i:i+1,p=a.MathUtils.lerp(t.candelaValues[i][r],t.candelaValues[d][r],h),g=a.MathUtils.lerp(t.candelaValues[i][r+1],t.candelaValues[d][r+1],h);return a.MathUtils.lerp(p,g,m)}const r=t.horAngles[0],i=t.horAngles[t.numHorAngles-1];for(let t=0;t<64800;++t){let a=t%360;const o=Math.floor(t/360);i-r!=0&&(a<r||a>=i)&&(a%=2*i,a>i&&(a=2*i-a)),e[t]=n(o,a)}return e}load(t,e,n,r){const o=new a.FileLoader(this.manager);o.setResponseType("text"),o.setCrossOrigin(this.crossOrigin),o.setWithCredentials(this.withCredentials),o.setPath(this.path),o.setRequestHeader(this.requestHeader);const s=new a.DataTexture(null,360,180,a.RedFormat,a.FloatType);return s.minFilter=a.LinearFilter,s.magFilter=a.LinearFilter,o.load(t,(t=>{const n=new i(t);s.image.data=this._getIESValues(n),s.needsUpdate=!0,void 0!==e&&e(s)}),n,r),s}parse(t){const e=new i(t),n=new a.DataTexture(null,360,180,a.RedFormat,a.FloatType);return n.minFilter=a.LinearFilter,n.magFilter=a.LinearFilter,n.image.data=this._getIESValues(e),n.needsUpdate=!0,n}}})),r.register("8Wcby",(function(e,n){t(e.exports,"DenoiseMaterial",(()=>o));var a=r("ilwiq"),i=r("9fZ6X");class o extends i.MaterialBase{constructor(t){super({blending:a.NoBlending,transparent:!1,depthWrite:!1,depthTest:!1,defines:{USE_SLIDER:0},uniforms:{sigma:{value:5},threshold:{value:.03},kSigma:{value:1},map:{value:null}},vertexShader:"\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\n\t\t\t",fragmentShader:"\n\n\t\t\t\t//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t\t\t\t//  Copyright (c) 2018-2019 Michele Morrone\n\t\t\t\t//  All rights reserved.\n\t\t\t\t//\n\t\t\t\t//  https://michelemorrone.eu - https://BrutPitt.com\n\t\t\t\t//\n\t\t\t\t//  me@michelemorrone.eu - brutpitt@gmail.com\n\t\t\t\t//  twitter: @BrutPitt - github: BrutPitt\n\t\t\t\t//\n\t\t\t\t//  https://github.com/BrutPitt/glslSmartDeNoise/\n\t\t\t\t//\n\t\t\t\t//  This software is distributed under the terms of the BSD 2-Clause license\n\t\t\t\t//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\t\t\t\tuniform sampler2D map;\n\n\t\t\t\tuniform float sigma;\n\t\t\t\tuniform float threshold;\n\t\t\t\tuniform float kSigma;\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t#define INV_SQRT_OF_2PI 0.39894228040143267793994605993439\n\t\t\t\t#define INV_PI 0.31830988618379067153776752674503\n\n\t\t\t\t// Parameters:\n\t\t\t\t//\t sampler2D tex\t - sampler image / texture\n\t\t\t\t//\t vec2 uv\t\t   - actual fragment coord\n\t\t\t\t//\t float sigma  >  0 - sigma Standard Deviation\n\t\t\t\t//\t float kSigma >= 0 - sigma coefficient\n\t\t\t\t//\t\t kSigma * sigma  --\x3e  radius of the circular kernel\n\t\t\t\t//\t float threshold   - edge sharpening threshold\n\t\t\t\tvec4 smartDeNoise( sampler2D tex, vec2 uv, float sigma, float kSigma, float threshold ) {\n\n\t\t\t\t\tfloat radius = round( kSigma * sigma );\n\t\t\t\t\tfloat radQ = radius * radius;\n\n\t\t\t\t\tfloat invSigmaQx2 = 0.5 / ( sigma * sigma );\n\t\t\t\t\tfloat invSigmaQx2PI = INV_PI * invSigmaQx2;\n\n\t\t\t\t\tfloat invThresholdSqx2 = 0.5 / ( threshold * threshold );\n\t\t\t\t\tfloat invThresholdSqrt2PI = INV_SQRT_OF_2PI / threshold;\n\n\t\t\t\t\tvec4 centrPx = texture2D( tex, uv );\n\t\t\t\t\tcentrPx.rgb *= centrPx.a;\n\n\t\t\t\t\tfloat zBuff = 0.0;\n\t\t\t\t\tvec4 aBuff = vec4( 0.0 );\n\t\t\t\t\tvec2 size = vec2( textureSize( tex, 0 ) );\n\n\t\t\t\t\tvec2 d;\n\t\t\t\t\tfor ( d.x = - radius; d.x <= radius; d.x ++ ) {\n\n\t\t\t\t\t\tfloat pt = sqrt( radQ - d.x * d.x );\n\n\t\t\t\t\t\tfor ( d.y = - pt; d.y <= pt; d.y ++ ) {\n\n\t\t\t\t\t\t\tfloat blurFactor = exp( - dot( d, d ) * invSigmaQx2 ) * invSigmaQx2PI;\n\n\t\t\t\t\t\t\tvec4 walkPx = texture2D( tex, uv + d / size );\n\t\t\t\t\t\t\twalkPx.rgb *= walkPx.a;\n\n\t\t\t\t\t\t\tvec4 dC = walkPx - centrPx;\n\t\t\t\t\t\t\tfloat deltaFactor = exp( - dot( dC.rgba, dC.rgba ) * invThresholdSqx2 ) * invThresholdSqrt2PI * blurFactor;\n\n\t\t\t\t\t\t\tzBuff += deltaFactor;\n\t\t\t\t\t\t\taBuff += deltaFactor * walkPx;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn aBuff / zBuff;\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = smartDeNoise( map, vec2( vUv.x, vUv.y ), sigma, kSigma, threshold );\n\t\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t\t#include <encodings_fragment>\n\t\t\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t\t\t}\n\n\t\t\t"}),this.setValues(t)}}})),r.register("1TZNq",(function(e,n){t(e.exports,"GraphMaterial",(()=>o));var a=r("ilwiq"),i=r("9fZ6X");class o extends i.MaterialBase{get graphFunctionSnippet(){return this._graphFunctionSnippet}set graphFunctionSnippet(t){this._graphFunctionSnippet=t}constructor(t){super({blending:a.NoBlending,transparent:!1,depthWrite:!1,depthTest:!1,defines:{USE_SLIDER:0},uniforms:{dim:{value:!0},thickness:{value:1},graphCount:{value:4},graphDisplay:{value:new a.Vector4(1,1,1,1)},overlay:{value:!0},xRange:{value:new a.Vector2(-2,2)},yRange:{value:new a.Vector2(-2,2)},colors:{value:[new a.Color(15277667).convertSRGBToLinear(),new a.Color(5025616).convertSRGBToLinear(),new a.Color(240116).convertSRGBToLinear(),new a.Color(16761095).convertSRGBToLinear()]}},vertexShader:"\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\n\t\t\t",fragmentShader:"\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform bool overlay;\n\t\t\t\tuniform bool dim;\n\t\t\t\tuniform bvec4 graphDisplay;\n\t\t\t\tuniform float graphCount;\n\t\t\t\tuniform float thickness;\n\t\t\t\tuniform vec2 xRange;\n\t\t\t\tuniform vec2 yRange;\n\t\t\t\tuniform vec3 colors[ 4 ];\n\n\t\t\t\t__FUNCTION_CONTENT__\n\n\t\t\t\tfloat map( float _min, float _max, float v ) {\n\n\t\t\t\t\tfloat len = _max - _min;\n\t\t\t\t\treturn _min + len * v;\n\n\t\t\t\t}\n\n\t\t\t\tvec3 getBackground( vec2 point, float steepness ) {\n\n\t\t\t\t\tvec2 pw = fwidth( point );\n\t\t\t\t\tvec2 halfWidth = pw * 0.5;\n\n\t\t\t\t\t// x, y axes\n\t\t\t\t\tvec2 distToZero = smoothstep(\n\t\t\t\t\t\t- halfWidth * 0.5,\n\t\t\t\t\t\thalfWidth * 0.5,\n\t\t\t\t\t\tabs( point.xy ) - pw\n\t\t\t\t\t);\n\n\t\t\t\t\t// 1 unit markers\n\t\t\t\t\tvec2 temp;\n\t\t\t\t\tvec2 modAxis = abs( modf( point + vec2( 0.5 ), temp ) ) - 0.5;\n\t\t\t\t\tvec2 distToAxis = smoothstep(\n\t\t\t\t\t\t- halfWidth,\n\t\t\t\t\t\thalfWidth,\n\t\t\t\t\t\tabs( modAxis.xy ) - pw * 0.5\n\t\t\t\t\t);\n\n\t\t\t\t\t// if we're at a chart boundary then remove the artifacts\n\t\t\t\t\tif ( abs( pw.y ) > steepness * 0.5 ) {\n\n\t\t\t\t\t\tdistToZero.y = 1.0;\n\t\t\t\t\t\tdistToAxis.y = 1.0;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// mix colors into a background color\n\t\t\t\t\tfloat axisIntensity = 1.0 - min( distToZero.x, distToZero.y );\n\t\t\t\t\tfloat markerIntensity = 1.0 - min( distToAxis.x, distToAxis.y );\n\n\t\t\t\t\tvec3 markerColor = mix( vec3( 0.005 ), vec3( 0.05 ), markerIntensity );\n\t\t\t\t\tvec3 backgroundColor = mix( markerColor, vec3( 0.2 ), axisIntensity );\n\t\t\t\t\treturn backgroundColor;\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t// from uniforms\n\t\t\t\t\tfloat sectionCount = overlay ? 1.0 : graphCount;\n\t\t\t\t\tfloat yWidth = abs( yRange.y - yRange.x );\n\n\t\t\t\t\t// separate into sections\n\t\t\t\t\tfloat _section;\n\t\t\t\t\tfloat sectionY = modf( sectionCount * vUv.y, _section );\n\t\t\t\t\tint section = int( sectionCount - _section - 1.0 );\n\n\t\t\t\t\t// get the current point\n\t\t\t\t\tvec2 point = vec2(\n\t\t\t\t\t\tmap( xRange.x, xRange.y, vUv.x ),\n\t\t\t\t\t\tmap( yRange.x, yRange.y, sectionY )\n\t\t\t\t\t);\n\n\t\t\t\t\t// get the results\n\t\t\t\t\tvec4 result = graphFunction( point.x );\n\t\t\t\t\tvec4 delta = result - vec4( point.y );\n\t\t\t\t\tvec4 halfDdf = fwidth( delta ) * 0.5;\n\t\t\t\t\tif ( fwidth( point.y ) > yWidth * 0.5 ) {\n\n\t\t\t\t\t\thalfDdf = vec4( 0.0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// graph display intensity\n\t\t\t\t\tvec4 graph = smoothstep( - halfDdf, halfDdf, abs( delta ) - thickness * halfDdf );\n\n\t\t\t\t\t// initialize the background\n\t\t\t\t\tgl_FragColor.rgb = getBackground( point, yWidth );\n\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t\tif ( dim && ( point.x < 0.0 || point.y < 0.0 ) ) {\n\n\t\t\t\t\t\tgraph = mix(\n\t\t\t\t\t\t\tvec4( 1.0 ),\n\t\t\t\t\t\t\tgraph,\n\t\t\t\t\t\t\t0.05\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// color the charts\n\t\t\t\t\tif ( sectionCount > 1.0 ) {\n\n\t\t\t\t\t\tif ( graphDisplay[ section ] ) {\n\n\t\t\t\t\t\t\tgl_FragColor.rgb = mix(\n\t\t\t\t\t\t\t\tcolors[ section ],\n\t\t\t\t\t\t\t\tgl_FragColor.rgb,\n\t\t\t\t\t\t\t\tgraph[ section ]\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor ( int i = 0; i < int( graphCount ); i ++ ) {\n\n\t\t\t\t\t\t\tif ( graphDisplay[ i ] ) {\n\n\t\t\t\t\t\t\t\tgl_FragColor.rgb = mix(\n\t\t\t\t\t\t\t\t\tcolors[ i ],\n\t\t\t\t\t\t\t\t\tgl_FragColor.rgb,\n\t\t\t\t\t\t\t\t\tgraph[ i ]\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t#include <encodings_fragment>\n\n\t\t\t\t}\n\n\t\t\t"}),this._graphFunctionSnippet="\n\t\t\tvec4 graphFunctionSnippet( float x ) {\n\n\t\t\t\treturn vec4(\n\t\t\t\t\tsin( x * 3.1415926535 ),\n\t\t\t\t\tcos( x ),\n\t\t\t\t\t0.0,\n\t\t\t\t\t0.0\n\t\t\t\t);\n\n\t\t\t}\n\t\t",this.setValues(t)}onBeforeCompile(t){return t.fragmentShader=t.fragmentShader.replace("__FUNCTION_CONTENT__",this._graphFunctionSnippet),t}customProgramCacheKey(){return this._graphFunctionSnippet}}})),r.register("ieQ3q",(function(e,n){t(e.exports,"PhysicalPathTracingMaterial",(()=>E));var a=r("ilwiq"),i=r("9fZ6X"),o=r("8Zfx2"),s=r("iyhQ7"),l=r("kAJM1"),c=r("TWVPU"),u=r("8nCwU"),f=r("6Q19u"),h=r("laA5G"),m=r("12pjC"),d=r("ejeD6"),p=r("7Ee23"),g=r("euxcz"),v=r("kiOyI"),x=r("azDH8"),y=r("614HA"),b=r("k3NkH"),T=r("a0p7X"),S=r("6WG26"),w=r("jJR4H"),R=r("59dZo"),F=r("Cp64s"),D=r("6T5Sj"),C=r("ibAuh"),I=r("hDPBH"),P=r("kmALz"),M=r("ffLvN"),_=r("kB2W0"),A=r("9h5et"),L=r("lrWoU"),O=r("auGOd");class E extends i.MaterialBase{onBeforeRender(){this.setDefine("FEATURE_DOF",0===this.physicalCamera.bokehSize?0:1),this.setDefine("FEATURE_BACKGROUND_MAP",this.backgroundMap?1:0),this.setDefine("FEATURE_FOG",this.materials.features.isUsed("FOG")?1:0)}constructor(t){super({transparent:!0,depthWrite:!1,defines:{FEATURE_MIS:1,FEATURE_RUSSIAN_ROULETTE:1,FEATURE_DOF:1,FEATURE_BACKGROUND_MAP:0,FEATURE_FOG:1,CAMERA_TYPE:0,ATTR_NORMAL:0,ATTR_TANGENT:1,ATTR_UV:2,ATTR_COLOR:3},uniforms:{resolution:{value:new a.Vector2},bounces:{value:10},transmissiveBounces:{value:10},physicalCamera:{value:new s.PhysicalCameraUniform},bvh:{value:new o.MeshBVHUniformStruct},attributesArray:{value:new f.AttributesTextureArray},materialIndexAttribute:{value:new o.UIntVertexAttributeTexture},materials:{value:new h.MaterialsTexture},textures:{value:(new m.RenderTarget2DArray).texture},lights:{value:new c.LightsInfoUniformStruct},iesProfiles:{value:(new u.IESProfilesTexture).texture},cameraWorldMatrix:{value:new a.Matrix4},invProjectionMatrix:{value:new a.Matrix4},backgroundBlur:{value:0},environmentIntensity:{value:1},environmentRotation:{value:new a.Matrix4},envMapInfo:{value:new l.EquirectHdrInfoUniform},backgroundMap:{value:null},seed:{value:0},opacity:{value:1},filterGlossyFactor:{value:0},backgroundAlpha:{value:1},sobolTexture:{value:null}},vertexShader:"\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 mvPosition = vec4( position, 1.0 );\n\t\t\t\t\tmvPosition = modelViewMatrix * mvPosition;\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t\tvUv = uv;\n\n\t\t\t\t}\n\n\t\t\t",fragmentShader:`\n\t\t\t\t#define RAY_OFFSET 1e-4\n\t\t\t\t#define INFINITY 1e20\n\n\t\t\t\tprecision highp isampler2D;\n\t\t\t\tprecision highp usampler2D;\n\t\t\t\tprecision highp sampler2DArray;\n\t\t\t\tvec4 envMapTexelToLinear( vec4 a ) { return a; }\n\t\t\t\t#include <common>\n\n\t\t\t\t// bvh intersection\n\t\t\t\t${o.shaderStructs}\n\t\t\t\t${o.shaderIntersectFunction}\n\n\t\t\t\t// random\n\t\t\t\t${P.pcgGLSL}\n\t\t\t\t${M.sobolCommonGLSL}\n\t\t\t\t${M.sobolSamplingGLSL}\n\n\t\t\t\t// common\n\t\t\t\t${I.arraySamplerTexelFetchGLSL}\n\t\t\t\t${C.fresnelGLSL}\n\t\t\t\t${D.utilsGLSL}\n\t\t\t\t${F.mathGLSL}\n\t\t\t\t${R.intersectShapesGLSL}\n\n\t\t\t\t// uniform structs\n\t\t\t\t${d.cameraStructGLSL}\n\t\t\t\t${g.lightsStructGLSL}\n\t\t\t\t${p.equirectStructGLSL}\n\t\t\t\t${v.materialStructGLSL}\n\t\t\t\t${x.fogMaterialBvhGLSL}\n\n\t\t\t\t// sampling\n\t\t\t\t${w.shapeSamplingGLSL}\n\t\t\t\t${y.bsdfSamplingGLSL}\n\t\t\t\t${T.equirectSamplingGLSL}\n\t\t\t\t${S.lightSamplingGLSL}\n\t\t\t\t${b.fogGLSL}\n\n\t\t\t\t// environment\n\t\t\t\tuniform EquirectHdrInfo envMapInfo;\n\t\t\t\tuniform mat4 environmentRotation;\n\t\t\t\tuniform float environmentIntensity;\n\n\t\t\t\t// lighting\n\t\t\t\tuniform sampler2DArray iesProfiles;\n\t\t\t\tuniform LightsInfo lights;\n\n\t\t\t\t// background\n\t\t\t\tuniform float backgroundBlur;\n\t\t\t\tuniform float backgroundAlpha;\n\t\t\t\t#if FEATURE_BACKGROUND_MAP\n\n\t\t\t\tuniform sampler2D backgroundMap;\n\n\t\t\t\t#endif\n\n\t\t\t\t// camera\n\t\t\t\tuniform mat4 cameraWorldMatrix;\n\t\t\t\tuniform mat4 invProjectionMatrix;\n\t\t\t\t#if FEATURE_DOF\n\n\t\t\t\tuniform PhysicalCamera physicalCamera;\n\n\t\t\t\t#endif\n\n\t\t\t\t// geometry\n\t\t\t\tuniform sampler2DArray attributesArray;\n\t\t\t\tuniform usampler2D materialIndexAttribute;\n\t\t\t\tuniform sampler2D materials;\n\t\t\t\tuniform sampler2DArray textures;\n\t\t\t\tuniform BVH bvh;\n\n\t\t\t\t// path tracer\n\t\t\t\tuniform int bounces;\n\t\t\t\tuniform int transmissiveBounces;\n\t\t\t\tuniform float filterGlossyFactor;\n\t\t\t\tuniform int seed;\n\n\t\t\t\t// image\n\t\t\t\tuniform vec2 resolution;\n\t\t\t\tuniform float opacity;\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t${_.cameraUtilsGLSL}\n\t\t\t\t${L.traceSceneGLSL}\n\t\t\t\t${A.attenuateHitGLSL}\n\n\t\t\t\tfloat applyFilteredGlossy( float roughness, float accumulatedRoughness ) {\n\n\t\t\t\t\treturn clamp(\n\t\t\t\t\t\tmax(\n\t\t\t\t\t\t\troughness,\n\t\t\t\t\t\t\taccumulatedRoughness * filterGlossyFactor * 5.0 ),\n\t\t\t\t\t\t0.0,\n\t\t\t\t\t\t1.0\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t\tvec3 sampleBackground( vec3 direction, vec2 uv ) {\n\n\t\t\t\t\tvec3 sampleDir = normalize( direction + sampleHemisphere( direction, uv ) * 0.5 * backgroundBlur );\n\n\t\t\t\t\t#if FEATURE_BACKGROUND_MAP\n\n\t\t\t\t\treturn sampleEquirectColor( backgroundMap, sampleDir );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\treturn environmentIntensity * sampleEquirectColor( envMapInfo.map, sampleDir );\n\n\t\t\t\t\t#endif\n\n\t\t\t\t}\n\n\t\t\t\t${O.getSurfaceRecordGLSL}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t// init\n\t\t\t\t\trng_initialize( gl_FragCoord.xy, seed );\n\t\t\t\t\tsobolPixelIndex = ( uint( gl_FragCoord.x ) << 16 ) |  uint( gl_FragCoord.y );\n\t\t\t\t\tsobolPathIndex = uint( seed );\n\n\t\t\t\t\t// get camera ray\n\t\t\t\t\tvec3 rayDirection, rayOrigin;\n\t\t\t\t\tgetCameraRay( rayDirection, rayOrigin );\n\n\t\t\t\t\t// inverse environment rotation\n\t\t\t\t\tmat3 envRotation3x3 = mat3( environmentRotation );\n\t\t\t\t\tmat3 invEnvRotation3x3 = inverse( envRotation3x3 );\n\t\t\t\t\tfloat lightsDenom = environmentIntensity == 0.0 && lights.count != 0u ? float( lights.count ) : float( lights.count + 1u );\n\n\t\t\t\t\t// final color\n\t\t\t\t\tgl_FragColor = vec4( 0.0 );\n\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t\t// hit results\n\t\t\t\t\tuvec4 faceIndices = uvec4( 0u );\n\t\t\t\t\tvec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\n\t\t\t\t\tvec3 barycoord = vec3( 0.0 );\n\t\t\t\t\tfloat side = 1.0;\n\t\t\t\t\tfloat dist = 0.0;\n\n\t\t\t\t\t// path tracing state\n\t\t\t\t\tfloat accumulatedRoughness = 0.0;\n\t\t\t\t\tbool transmissiveRay = true;\n\t\t\t\t\tbool isShadowRay = false;\n\t\t\t\t\tint transmissiveTraversals = transmissiveBounces;\n\t\t\t\t\tvec3 throughputColor = vec3( 1.0 );\n\t\t\t\t\tScatterRecord sampleRec;\n\t\t\t\t\tint i;\n\n\t\t\t\t\tMaterial fogMaterial;\n\t\t\t\t\t#if FEATURE_FOG\n\n\t\t\t\t\tfogMaterial.fogVolume = bvhIntersectFogVolumeHit(\n\t\t\t\t\t\tbvh, rayOrigin, - rayDirection,\n\t\t\t\t\t\tmaterialIndexAttribute, materials,\n\t\t\t\t\t\tfogMaterial\n\t\t\t\t\t);\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tfor ( i = 0; i < bounces; i ++ ) {\n\n\t\t\t\t\t\tsobolBounceIndex ++;\n\n\t\t\t\t\t\tbool firstRay = i == 0 && transmissiveTraversals == transmissiveBounces;\n\n\t\t\t\t\t\tLightSampleRecord lightSampleRec;\n\t\t\t\t\t\tint hitType = traceScene(\n\t\t\t\t\t\t\trayOrigin, rayDirection,\n\t\t\t\t\t\t\tbvh, lights, fogMaterial,\n\t\t\t\t\t\t\tfaceIndices, faceNormal, barycoord, side, dist,\n\t\t\t\t\t\t\tlightSampleRec\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif ( hitType == LIGHT_HIT ) {\n\n\t\t\t\t\t\t\tif ( firstRay || transmissiveRay ) {\n\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += lightSampleRec.emission * throughputColor;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t#if FEATURE_MIS\n\n\t\t\t\t\t\t\t\t// NOTE: we skip MIS for punctual lights since they are not supported in forward PT case\n\t\t\t\t\t\t\t\tif ( lightSampleRec.type == SPOT_LIGHT_TYPE || lightSampleRec.type == DIR_LIGHT_TYPE || lightSampleRec.type == POINT_LIGHT_TYPE ) {\n\n\t\t\t\t\t\t\t\t\tgl_FragColor.rgb += lightSampleRec.emission * throughputColor;\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// weight the contribution\n\t\t\t\t\t\t\t\t\tfloat misWeight = misHeuristic( sampleRec.pdf, lightSampleRec.pdf / lightsDenom );\n\t\t\t\t\t\t\t\t\tgl_FragColor.rgb += lightSampleRec.emission * throughputColor * misWeight;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += lightSampleRec.emission * throughputColor;\n\n\t\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t} else if ( hitType == NO_HIT ) {\n\n\t\t\t\t\t\t\tif ( firstRay || transmissiveRay ) {\n\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += sampleBackground( envRotation3x3 * rayDirection, sobol2( 2 ) ) * throughputColor;\n\t\t\t\t\t\t\t\tgl_FragColor.a = backgroundAlpha;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t#if FEATURE_MIS\n\n\t\t\t\t\t\t\t\t// get the PDF of the hit envmap point\n\t\t\t\t\t\t\t\tvec3 envColor;\n\t\t\t\t\t\t\t\tfloat envPdf = sampleEquirect( envMapInfo, envRotation3x3 * rayDirection, envColor );\n\t\t\t\t\t\t\t\tenvPdf /= lightsDenom;\n\n\t\t\t\t\t\t\t\t// and weight the contribution\n\t\t\t\t\t\t\t\tfloat misWeight = misHeuristic( sampleRec.pdf, envPdf );\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += environmentIntensity * envColor * throughputColor * misWeight;\n\n\t\t\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\t\tgl_FragColor.rgb +=\n\t\t\t\t\t\t\t\t\tenvironmentIntensity *\n\t\t\t\t\t\t\t\t\tsampleEquirectColor( envMapInfo.map, envRotation3x3 * rayDirection ) *\n\t\t\t\t\t\t\t\t\tthroughputColor;\n\n\t\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, faceIndices.x ).r;\n\t\t\t\t\t\tMaterial material = readMaterialInfo( materials, materialIndex );\n\n\t\t\t\t\t\t#if FEATURE_FOG\n\n\t\t\t\t\t\tif ( hitType == FOG_HIT ) {\n\n\t\t\t\t\t\t\tmaterial = fogMaterial;\n\t\t\t\t\t\t\taccumulatedRoughness += 0.2;\n\n\t\t\t\t\t\t} else if ( material.fogVolume ) {\n\n\t\t\t\t\t\t\tfogMaterial = material;\n\t\t\t\t\t\t\tfogMaterial.fogVolume = side == 1.0;\n\n\t\t\t\t\t\t\trayOrigin = stepRayOrigin( rayOrigin, rayDirection, - faceNormal, dist );\n\n\t\t\t\t\t\t\ti -= sign( transmissiveTraversals );\n\t\t\t\t\t\t\ttransmissiveTraversals -= sign( transmissiveTraversals );\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\tif ( material.matte && firstRay ) {\n\n\t\t\t\t\t\t\tgl_FragColor = vec4( 0.0 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if we've determined that this is a shadow ray and we've hit an item with no shadow casting\n\t\t\t\t\t\t// then skip it\n\t\t\t\t\t\tif ( ! material.castShadow && isShadowRay ) {\n\n\t\t\t\t\t\t\trayOrigin = stepRayOrigin( rayOrigin, rayDirection, - faceNormal, dist );\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tSurfaceRecord surf;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tgetSurfaceRecord(\n\t\t\t\t\t\t\t\tmaterial, attributesArray, side, barycoord, faceIndices,\n\t\t\t\t\t\t\t\tfaceNormal, accumulatedRoughness,\n\t\t\t\t\t\t\t\tsurf\n\t\t\t\t\t\t\t) == SKIP_SURFACE\n\t\t\t\t\t\t) {\n\n\t\t\t\t\t\t\t// only allow a limited number of transparency discards otherwise we could\n\t\t\t\t\t\t\t// crash the context with too long a loop.\n\t\t\t\t\t\t\ti -= sign( transmissiveTraversals );\n\t\t\t\t\t\t\ttransmissiveTraversals -= sign( transmissiveTraversals );\n\n\t\t\t\t\t\t\trayOrigin = stepRayOrigin( rayOrigin, rayDirection, - faceNormal, dist );\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfaceNormal = surf.faceNormal;\n\n\t\t\t\t\t\tmat3 normalBasis = getBasisFromNormal( surf.normal );\n\t\t\t\t\t\tmat3 invBasis = inverse( normalBasis );\n\n\t\t\t\t\t\tmat3 clearcoatNormalBasis = getBasisFromNormal( surf.clearcoatNormal );\n\t\t\t\t\t\tmat3 clearcoatInvBasis = inverse( clearcoatNormalBasis );\n\n\t\t\t\t\t\tvec3 outgoing = - normalize( invBasis * rayDirection );\n\t\t\t\t\t\tvec3 clearcoatOutgoing = - normalize( clearcoatInvBasis * rayDirection );\n\t\t\t\t\t\tsampleRec = bsdfSample( outgoing, clearcoatOutgoing, normalBasis, invBasis, clearcoatNormalBasis, clearcoatInvBasis, surf );\n\n\t\t\t\t\t\tbool wasBelowSurface = ! surf.volumeParticle && dot( rayDirection, faceNormal ) > 0.0;\n\t\t\t\t\t\tisShadowRay = sampleRec.specularPdf < sobol( 4 );\n\n\t\t\t\t\t\tvec3 prevRayDirection = rayDirection;\n\t\t\t\t\t\trayDirection = normalize( normalBasis * sampleRec.direction );\n\n\t\t\t\t\t\tbool isBelowSurface = ! surf.volumeParticle && dot( rayDirection, faceNormal ) < 0.0;\n\t\t\t\t\t\trayOrigin = stepRayOrigin( rayOrigin, prevRayDirection, isBelowSurface ? - faceNormal : faceNormal, dist );\n\n\t\t\t\t\t\t// direct env map sampling\n\t\t\t\t\t\t#if FEATURE_MIS\n\n\t\t\t\t\t\t// uniformly pick a light or environment map\n\t\t\t\t\t\tif( lightsDenom != 0.0 && sobol( 5 ) < float( lights.count ) / lightsDenom ) {\n\n\t\t\t\t\t\t\t// sample a light or environment\n\t\t\t\t\t\t\tLightSampleRecord lightSampleRec = randomLightSample( lights.tex, iesProfiles, lights.count, rayOrigin, sobol3( 6 ) );\n\n\t\t\t\t\t\t\tbool isSampleBelowSurface = ! surf.volumeParticle && dot( faceNormal, lightSampleRec.direction ) < 0.0;\n\t\t\t\t\t\t\tif ( isSampleBelowSurface ) {\n\n\t\t\t\t\t\t\t\tlightSampleRec.pdf = 0.0;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// check if a ray could even reach the light area\n\t\t\t\t\t\t\tvec3 attenuatedColor;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tlightSampleRec.pdf > 0.0 &&\n\t\t\t\t\t\t\t\tisDirectionValid( lightSampleRec.direction, surf.normal, faceNormal ) &&\n\t\t\t\t\t\t\t\t! attenuateHit( bvh, rayOrigin, lightSampleRec.direction, lightSampleRec.dist, bounces - i, transmissiveTraversals, isShadowRay, fogMaterial, attenuatedColor )\n\t\t\t\t\t\t\t) {\n\n\t\t\t\t\t\t\t\t// get the material pdf\n\t\t\t\t\t\t\t\tvec3 sampleColor;\n\t\t\t\t\t\t\t\tfloat lightMaterialPdf = bsdfResult( outgoing, clearcoatOutgoing, normalize( invBasis * lightSampleRec.direction ), normalize( clearcoatInvBasis * lightSampleRec.direction ), surf, sampleColor );\n\t\t\t\t\t\t\t\tbool isValidSampleColor = all( greaterThanEqual( sampleColor, vec3( 0.0 ) ) );\n\t\t\t\t\t\t\t\tif ( lightMaterialPdf > 0.0 && isValidSampleColor ) {\n\n\t\t\t\t\t\t\t\t\t// weight the direct light contribution\n\t\t\t\t\t\t\t\t\tfloat lightPdf = lightSampleRec.pdf / lightsDenom;\n\t\t\t\t\t\t\t\t\tfloat misWeight = lightSampleRec.type == SPOT_LIGHT_TYPE || lightSampleRec.type == DIR_LIGHT_TYPE || lightSampleRec.type == POINT_LIGHT_TYPE ? 1.0 : misHeuristic( lightPdf, lightMaterialPdf );\n\t\t\t\t\t\t\t\t\tgl_FragColor.rgb += attenuatedColor * lightSampleRec.emission * throughputColor * sampleColor * misWeight / lightPdf;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// find a sample in the environment map to include in the contribution\n\t\t\t\t\t\t\tvec3 envColor, envDirection;\n\t\t\t\t\t\t\tfloat envPdf = sampleEquirectProbability( envMapInfo, sobol2( 7 ), envColor, envDirection );\n\t\t\t\t\t\t\tenvDirection = invEnvRotation3x3 * envDirection;\n\n\t\t\t\t\t\t\t// this env sampling is not set up for transmissive sampling and yields overly bright\n\t\t\t\t\t\t\t// results so we ignore the sample in this case.\n\t\t\t\t\t\t\t// TODO: this should be improved but how? The env samples could traverse a few layers?\n\t\t\t\t\t\t\tbool isSampleBelowSurface = ! surf.volumeParticle && dot( faceNormal, envDirection ) < 0.0;\n\t\t\t\t\t\t\tif ( isSampleBelowSurface ) {\n\n\t\t\t\t\t\t\t\tenvPdf = 0.0;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// check if a ray could even reach the surface\n\t\t\t\t\t\t\tvec3 attenuatedColor;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tenvPdf > 0.0 &&\n\t\t\t\t\t\t\t\tisDirectionValid( envDirection, surf.normal, faceNormal ) &&\n\t\t\t\t\t\t\t\t! attenuateHit( bvh, rayOrigin, envDirection, INFINITY, bounces - i, transmissiveTraversals, isShadowRay, fogMaterial, attenuatedColor )\n\t\t\t\t\t\t\t) {\n\n\t\t\t\t\t\t\t\t// get the material pdf\n\t\t\t\t\t\t\t\tvec3 sampleColor;\n\t\t\t\t\t\t\t\tfloat envMaterialPdf = bsdfResult( outgoing, clearcoatOutgoing, normalize( invBasis * envDirection ), normalize( clearcoatInvBasis * envDirection ), surf, sampleColor );\n\t\t\t\t\t\t\t\tbool isValidSampleColor = all( greaterThanEqual( sampleColor, vec3( 0.0 ) ) );\n\t\t\t\t\t\t\t\tif ( envMaterialPdf > 0.0 && isValidSampleColor ) {\n\n\t\t\t\t\t\t\t\t\t// weight the direct light contribution\n\t\t\t\t\t\t\t\t\tenvPdf /= lightsDenom;\n\t\t\t\t\t\t\t\t\tfloat misWeight = misHeuristic( envPdf, envMaterialPdf );\n\t\t\t\t\t\t\t\t\tgl_FragColor.rgb += attenuatedColor * environmentIntensity * envColor * throughputColor * sampleColor * misWeight / envPdf;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// accumulate a roughness value to offset diffuse, specular, diffuse rays that have high contribution\n\t\t\t\t\t\t// to a single pixel resulting in fireflies\n\t\t\t\t\t\tif ( ! surf.volumeParticle && ! isBelowSurface ) {\n\n\t\t\t\t\t\t\t// determine if this is a rough normal or not by checking how far off straight up it is\n\t\t\t\t\t\t\tvec3 halfVector = normalize( outgoing + sampleRec.direction );\n\t\t\t\t\t\t\tvec3 clearcoatHalfVector = normalize( clearcoatOutgoing + sampleRec.clearcoatDirection );\n\t\t\t\t\t\t\taccumulatedRoughness += max( sin( acosApprox( halfVector.z ) ), sin( acosApprox( clearcoatHalfVector.z ) ) );\n\n\t\t\t\t\t\t\ttransmissiveRay = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if we're bouncing around the inside a transmissive material then decrement\n\t\t\t\t\t\t// perform this separate from a bounce\n\t\t\t\t\t\tbool isTransmissiveRay = ! surf.volumeParticle && dot( rayDirection, faceNormal * side ) < 0.0;\n\t\t\t\t\t\tif ( ( isTransmissiveRay || isBelowSurface ) && transmissiveTraversals > 0 ) {\n\n\t\t\t\t\t\t\ttransmissiveTraversals --;\n\t\t\t\t\t\t\ti --;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// accumulate color\n\t\t\t\t\t\tgl_FragColor.rgb += ( surf.emission * throughputColor );\n\n\t\t\t\t\t\t// skip the sample if our PDF or ray is impossible\n\t\t\t\t\t\tif ( sampleRec.pdf <= 0.0 || ! isDirectionValid( rayDirection, surf.normal, faceNormal ) ) {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t#if FEATURE_RUSSIAN_ROULETTE\n\n\t\t\t\t\t\t// russian roulette path termination\n\t\t\t\t\t\t// https://www.arnoldrenderer.com/research/physically_based_shader_design_in_arnold.pdf\n\t\t\t\t\t\tuint minBounces = 3u;\n\t\t\t\t\t\tfloat depthProb = float( sobolBounceIndex < minBounces );\n\n\t\t\t\t\t\tfloat rrProb = luminance( throughputColor * sampleRec.color / sampleRec.pdf );\n\t\t\t\t\t\trrProb /= luminance( throughputColor );\n\t\t\t\t\t\trrProb = sqrt( rrProb );\n\t\t\t\t\t\trrProb = max( rrProb, depthProb );\n\t\t\t\t\t\trrProb = min( rrProb, 1.0 );\n\t\t\t\t\t\tif ( sobol( 8 ) > rrProb ) {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// perform sample clamping here to avoid bright pixels\n\t\t\t\t\t\tthroughputColor *= min( 1.0 / rrProb, 20.0 );\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\tthroughputColor *= sampleRec.color / sampleRec.pdf;\n\n\t\t\t\t\t\t// attenuate the throughput color by the medium color\n\t\t\t\t\t\tif ( side == - 1.0 ) {\n\n\t\t\t\t\t\t\tthroughputColor *= transmissionAttenuation( dist, surf.attenuationColor, surf.attenuationDistance );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// discard the sample if there are any NaNs\n\t\t\t\t\t\tif ( any( isnan( throughputColor ) ) || any( isinf( throughputColor ) ) ) {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgl_FragColor.a *= opacity;\n\n\t\t\t\t}\n\n\t\t\t`}),this.setValues(t)}}})),r.register("iyhQ7",(function(e,n){t(e.exports,"PhysicalCameraUniform",(()=>i));var a=r("kLfIo");class i{constructor(){this.bokehSize=0,this.apertureBlades=0,this.apertureRotation=0,this.focusDistance=10,this.anamorphicRatio=1}updateFrom(t){t instanceof a.PhysicalCamera?(this.bokehSize=t.bokehSize,this.apertureBlades=t.apertureBlades,this.apertureRotation=t.apertureRotation,this.focusDistance=t.focusDistance,this.anamorphicRatio=t.anamorphicRatio):(this.bokehSize=0,this.apertureRotation=0,this.apertureBlades=0,this.focusDistance=10,this.anamorphicRatio=1)}}})),r.register("kAJM1",(function(e,n){t(e.exports,"EquirectHdrInfoUniform",(()=>s));var a=r("ilwiq");function i(t,e,n=0,a=t.length){let r=n,i=n+a-1;for(;r<i;){const n=r+i>>1;t[n]<e?r=n+1:i=n}return r-n}function o(t,e,n){return.2126*t+.7152*e+.0722*n}class s{constructor(){const t=new a.DataTexture(new Float32Array([1,1,1,1]),1,1);t.type=a.FloatType,t.format=a.RGBAFormat,t.minFilter=a.LinearFilter,t.magFilter=a.LinearFilter,t.wrapS=a.RepeatWrapping,t.wrapT=a.RepeatWrapping,t.generateMipmaps=!1,t.needsUpdate=!0;const e=new a.DataTexture(new Float32Array([0,1]),1,2);e.type=a.FloatType,e.format=a.RedFormat,e.minFilter=a.LinearFilter,e.magFilter=a.LinearFilter,e.generateMipmaps=!1,e.needsUpdate=!0;const n=new a.DataTexture(new Float32Array([0,0,1,1]),2,2);n.type=a.FloatType,n.format=a.RedFormat,n.minFilter=a.LinearFilter,n.magFilter=a.LinearFilter,n.generateMipmaps=!1,n.needsUpdate=!0,this.map=t,this.marginalWeights=e,this.conditionalWeights=n,this.totalSumWhole=1,this.totalSumDecimal=0}dispose(){this.marginalWeights.dispose(),this.conditionalWeights.dispose(),this.map.dispose()}updateFrom(t){const e=function(t){const e=t.clone();e.source=new a.Source({...e.image});const{width:n,height:r,data:i}=e.image;let o=i;if(e.type===a.HalfFloatType){o=new Float32Array(i.length);for(const t in i)o[t]=a.DataUtils.fromHalfFloat(i[t]);e.image.data=o,e.type=a.FloatType}if(e.flipY){const t=o;o=o.slice();for(let e=0;e<r;e++)for(let a=0;a<n;a++){const i=4*(e*n+a),s=4*((r-e-1)*n+a);o[s+0]=t[i+0],o[s+1]=t[i+1],o[s+2]=t[i+2],o[s+3]=t[i+3]}e.flipY=!1,e.image.data=o}return e}(t);e.wrapS=a.RepeatWrapping,e.wrapT=a.RepeatWrapping;const{width:n,height:r,data:s}=e.image,l=new Float32Array(n*r),c=new Float32Array(n*r),u=new Float32Array(r),f=new Float32Array(r);let h=0,m=0;for(let t=0;t<r;t++){let e=0;for(let a=0;a<n;a++){const r=t*n+a,i=o(s[4*r+0],s[4*r+1],s[4*r+2]);e+=i,h+=i,l[r]=i,c[r]=e}if(0!==e)for(let a=t*n,r=t*n+n;a<r;a++)l[a]/=e,c[a]/=e;m+=e,u[t]=e,f[t]=m}if(0!==m)for(let t=0,e=u.length;t<e;t++)u[t]/=m,f[t]/=m;const d=new Float32Array(r),p=new Float32Array(n*r);for(let t=0;t<r;t++){const e=i(f,(t+1)/r);d[t]=(e+.5)/r}for(let t=0;t<r;t++)for(let e=0;e<n;e++){const a=t*n+e,r=i(c,(e+1)/n,t*n,n);p[a]=(r+.5)/n}this.dispose();const{marginalWeights:g,conditionalWeights:v}=this;g.image={width:r,height:1,data:d},g.needsUpdate=!0,v.image={width:n,height:r,data:p},v.needsUpdate=!0;const x=~~h,y=h-x;this.totalSumWhole=x,this.totalSumDecimal=y,this.map=e}}})),r.register("TWVPU",(function(e,n){t(e.exports,"LightsInfoUniformStruct",(()=>i));var a=r("ilwiq");class i{constructor(){const t=new a.DataTexture(new Float32Array(4),1,1);t.format=a.RGBAFormat,t.type=a.FloatType,t.wrapS=a.ClampToEdgeWrapping,t.wrapT=a.ClampToEdgeWrapping,t.generateMipmaps=!1,this.tex=t,this.count=0}updateFrom(t,e=[]){const n=this.tex,r=Math.max(6*t.length,1),i=Math.ceil(Math.sqrt(r));n.image.width!==i&&(n.dispose(),n.image.data=new Float32Array(i*i*4),n.image.width=i,n.image.height=i);const o=n.image.data,s=new a.Vector3,l=new a.Vector3,c=new a.Matrix4,u=new a.Quaternion,f=new a.Vector3,h=new a.Vector3,m=new a.Vector3;for(let n=0,a=t.length;n<a;n++){const a=t[n],r=6*n*4;let i=0;a.getWorldPosition(l),o[r+i++]=l.x,o[r+i++]=l.y,o[r+i++]=l.z;let d=0;if(a.isRectAreaLight&&a.isCircular?d=1:a.isSpotLight?d=2:a.isDirectionalLight?d=3:a.isPointLight&&(d=4),o[r+i++]=d,o[r+i++]=a.color.r,o[r+i++]=a.color.g,o[r+i++]=a.color.b,o[r+i++]=a.intensity,a.getWorldQuaternion(u),a.isRectAreaLight)s.set(a.width,0,0).applyQuaternion(u),o[r+i++]=s.x,o[r+i++]=s.y,o[r+i++]=s.z,i++,l.set(0,a.height,0).applyQuaternion(u),o[r+i++]=l.x,o[r+i++]=l.y,o[r+i++]=l.z,o[r+i++]=s.cross(l).length()*(a.isCircular?Math.PI/4:1);else if(a.isSpotLight){const t=a.radius;f.setFromMatrixPosition(a.matrixWorld),h.setFromMatrixPosition(a.target.matrixWorld),c.lookAt(f,h,m),u.setFromRotationMatrix(c),s.set(1,0,0).applyQuaternion(u),o[r+i++]=s.x,o[r+i++]=s.y,o[r+i++]=s.z,i++,l.set(0,1,0).applyQuaternion(u),o[r+i++]=l.x,o[r+i++]=l.y,o[r+i++]=l.z,o[r+i++]=Math.PI*t*t,o[r+i++]=t,o[r+i++]=a.shadow.camera.near,o[r+i++]=a.decay,o[r+i++]=a.distance,o[r+i++]=Math.cos(a.angle),o[r+i++]=Math.cos(a.angle*(1-a.penumbra)),o[r+i++]=e.indexOf(a.iesTexture)}else if(a.isPointLight){const t=s.setFromMatrixPosition(a.matrixWorld);o[r+i++]=t.x,o[r+i++]=t.y,o[r+i++]=t.z,i++,i+=4,i+=2,o[r+i++]=a.decay,o[r+i++]=a.distance}else if(a.isDirectionalLight){const t=s.setFromMatrixPosition(a.matrixWorld),e=l.setFromMatrixPosition(a.target.matrixWorld);h.subVectors(t,e).normalize(),o[r+i++]=h.x,o[r+i++]=h.y,o[r+i++]=h.z}}n.needsUpdate=!0,this.count=t.length}}})),r.register("8nCwU",(function(e,n){t(e.exports,"IESProfilesTexture",(()=>l));var a=r("ilwiq"),i=r("RPVlj"),o=r("77Fts");const s=new a.Color;class l extends a.WebGLArrayRenderTarget{constructor(...t){super(...t);const e=this.texture;e.format=a.RGBAFormat,e.type=a.FloatType,e.minFilter=a.LinearFilter,e.magFilter=a.LinearFilter,e.wrapS=a.ClampToEdgeWrapping,e.wrapT=a.ClampToEdgeWrapping,e.generateMipmaps=!1,e.updateFrom=(...t)=>{this.updateFrom(...t)};const n=new i.FullScreenQuad(new a.MeshBasicMaterial);this.fsQuad=n,this.iesLoader=new o.IESLoader}async updateFrom(t,e){const n=t.getRenderTarget(),r=t.toneMapping,i=t.getClearAlpha();t.getClearColor(s);const o=e.length||1;this.setSize(360,180,o),t.setClearColor(0,0),t.toneMapping=a.NoToneMapping;const l=this.fsQuad;for(let n=0,a=o;n<a;n++){const a=e[n];a&&(a.matrixAutoUpdate=!1,a.matrix.identity(),l.material.map=a,l.material.transparent=!0,t.setRenderTarget(this,n),l.render(t),a.updateMatrix(),a.matrixAutoUpdate=!0)}l.material.map=null,t.setClearColor(s,i),t.setRenderTarget(n),t.toneMapping=r,l.dispose()}dispose(){super.dispose(),this.fsQuad.dispose()}}})),r.register("6Q19u",(function(e,n){t(e.exports,"AttributesTextureArray",(()=>i));var a=r("7Ie7O");class i extends a.FloatAttributeTextureArray{updateNormalAttribute(t){this.updateAttribute(0,t)}updateTangentAttribute(t){this.updateAttribute(1,t)}updateUvAttribute(t){this.updateAttribute(2,t)}updateColorAttribute(t){this.updateAttribute(3,t)}updateFrom(t,e,n,a){this.setAttributes([t,e,n,a])}}})),r.register("7Ie7O",(function(e,n){t(e.exports,"FloatAttributeTextureArray",(()=>s));var a=r("ilwiq"),i=r("8Zfx2");function o(t,e,n,a,r){if(e>a)throw new Error;const i=t.length/e,o=8*t.constructor.BYTES_PER_ELEMENT;let s=1;switch(t.constructor){case Uint8Array:case Uint16Array:case Uint32Array:s=2**o-1;break;case Int8Array:case Int16Array:case Int32Array:s=2**(o-1)-1}for(let o=0;o<i;o++){const i=4*o,l=e*o;for(let o=0;o<a;o++)n[r+i+o]=e>=o+1?t[l+o]/s:0}}class s extends a.DataArrayTexture{constructor(){super(),this._textures=[],this.type=a.FloatType,this.format=a.RGBAFormat,this.internalFormat="RGBA32F"}updateAttribute(t,e){const n=this._textures[t];n.updateFrom(e);const a=n.image,r=this.image;if(a.width!==r.width||a.height!==r.height)throw new Error("FloatAttributeTextureArray: Attribute must be the same dimensions when updating single layer.");const{width:i,height:s,data:l}=r,c=i*s*4*t;let u=e.itemSize;3===u&&(u=4),o(n.image.data,u,l,4,c),this.dispose(),this.needsUpdate=!0}setAttributes(t){const e=t[0].count,n=t.length;for(let a=0,r=n;a<r;a++)if(t[a].count!==e)throw new Error("FloatAttributeTextureArray: All attributes must have the same item count.");const a=this._textures;for(;a.length<n;){const t=new i.FloatVertexAttributeTexture;a.push(t)}for(;a.length>n;)a.pop();for(let e=0,r=n;e<r;e++)a[e].updateFrom(t[e]);const r=a[0].image,s=this.image;r.width===s.width&&r.height===s.height&&r.depth===n||(s.width=r.width,s.height=r.height,s.depth=n,s.data=new Float32Array(s.width*s.height*s.depth*4));const{data:l,width:c,height:u}=s;for(let e=0,r=n;e<r;e++){const n=a[e],r=c*u*4*e;let i=t[e].itemSize;3===i&&(i=4),o(n.image.data,i,l,4,r)}this.dispose(),this.needsUpdate=!0}}})),r.register("laA5G",(function(e,n){t(e.exports,"MaterialsTexture",(()=>l));var a=r("ilwiq"),i=r("kOapr");const o=180;class s{constructor(){this._features={}}isUsed(t){return t in this._features}setUsed(t,e=!0){!1===e?delete this._features[t]:this._features[t]=!0}reset(){this._features={}}}class l extends a.DataTexture{constructor(){super(new Float32Array(4),1,1),this.format=a.RGBAFormat,this.type=a.FloatType,this.wrapS=a.ClampToEdgeWrapping,this.wrapT=a.ClampToEdgeWrapping,this.generateMipmaps=!1,this.threeCompatibilityTransforms=!1,this.features=new s}setCastShadow(t,e){this.image.data[t*o+57]=e?0:1}getCastShadow(t){const e=this.image.data;return!Boolean(e[t*o+57])}setMatte(t,e){this.image.data[t*o+56]=e?1:0}getMatte(t){const e=this.image.data;return Boolean(e[t*o+56])}updateFrom(t,e){function n(t,e,n=-1){if(e in t&&t[e]){const n=i.getTextureHash(t[e]);return p[n]}return n}function r(t,e,n){return e in t?t[e]:n}function s(t,e,n,a){let r;if(r=f?function(t){return t.map||t.specularMap||t.displacementMap||t.normalMap||t.bumpMap||t.roughnessMap||t.metalnessMap||t.alphaMap||t.emissiveMap||t.clearcoatMap||t.clearcoatNormalMap||t.clearcoatRoughnessMap||t.iridescenceMap||t.iridescenceThicknessMap||t.specularIntensityMap||t.specularColorMap||t.transmissionMap||t.thicknessMap||t.sheenColorMap||t.sheenRoughnessMap||null}(t):t[e]&&t[e].isTexture?t[e]:null,r){const t=r.matrix.elements;let e=0;n[a+e++]=t[0],n[a+e++]=t[3],n[a+e++]=t[6],e++,n[a+e++]=t[1],n[a+e++]=t[4],n[a+e++]=t[7],e++}return 8}let l=0;const c=45*t.length,u=Math.ceil(Math.sqrt(c)),{threeCompatibilityTransforms:f,image:h,features:m}=this,d=i.reduceTexturesToUniqueSources(e),p={};for(let t=0,e=d.length;t<e;t++)p[i.getTextureHash(d[t])]=t;h.width!==u&&(this.dispose(),h.data=new Float32Array(u*u*4),h.width=u,h.height=u);const g=h.data;m.reset();for(let e=0,i=t.length;e<i;e++){const i=t[e];if(i.isFogVolumeMaterial){m.setUsed("FOG");for(let t=0;t<o;t++)g[l+t]=0;g[l+0+0]=i.color.r,g[l+0+1]=i.color.g,g[l+0+2]=i.color.b,g[l+8+3]=r(i,"emissiveIntensity",0),g[l+12+0]=i.emissive.r,g[l+12+1]=i.emissive.g,g[l+12+2]=i.emissive.b,g[l+52+1]=i.density,g[l+52+3]=0,g[l+56+2]=4,l+=o;continue}g[l++]=i.color.r,g[l++]=i.color.g,g[l++]=i.color.b,g[l++]=n(i,"map"),g[l++]=r(i,"metalness",0),g[l++]=n(i,"metalnessMap"),g[l++]=r(i,"roughness",0),g[l++]=n(i,"roughnessMap"),g[l++]=r(i,"ior",1.5),g[l++]=r(i,"transmission",0),g[l++]=n(i,"transmissionMap"),g[l++]=r(i,"emissiveIntensity",0),"emissive"in i?(g[l++]=i.emissive.r,g[l++]=i.emissive.g,g[l++]=i.emissive.b):(g[l++]=0,g[l++]=0,g[l++]=0),g[l++]=n(i,"emissiveMap"),g[l++]=n(i,"normalMap"),"normalScale"in i?(g[l++]=i.normalScale.x,g[l++]=i.normalScale.y):(g[l++]=1,g[l++]=1),g[l++]=r(i,"clearcoat",0),g[l++]=n(i,"clearcoatMap"),g[l++]=r(i,"clearcoatRoughness",0),g[l++]=n(i,"clearcoatRoughnessMap"),g[l++]=n(i,"clearcoatNormalMap"),"clearcoatNormalScale"in i?(g[l++]=i.clearcoatNormalScale.x,g[l++]=i.clearcoatNormalScale.y):(g[l++]=1,g[l++]=1),l++,g[l++]=r(i,"sheen",0),"sheenColor"in i?(g[l++]=i.sheenColor.r,g[l++]=i.sheenColor.g,g[l++]=i.sheenColor.b):(g[l++]=0,g[l++]=0,g[l++]=0),g[l++]=n(i,"sheenColorMap"),g[l++]=r(i,"sheenRoughness",0),g[l++]=n(i,"sheenRoughnessMap"),g[l++]=n(i,"iridescenceMap"),g[l++]=n(i,"iridescenceThicknessMap"),g[l++]=r(i,"iridescence",0),g[l++]=r(i,"iridescenceIOR",1.3);const c=r(i,"iridescenceThicknessRange",[100,400]);g[l++]=c[0],g[l++]=c[1],"specularColor"in i?(g[l++]=i.specularColor.r,g[l++]=i.specularColor.g,g[l++]=i.specularColor.b):(g[l++]=1,g[l++]=1,g[l++]=1),g[l++]=n(i,"specularColorMap"),g[l++]=r(i,"specularIntensity",1),g[l++]=n(i,"specularIntensityMap");const u=0===r(i,"thickness",0)&&r(i,"attenuationDistance",1/0)===1/0;if(g[l++]=Number(u),l++,"attenuationColor"in i?(g[l++]=i.attenuationColor.r,g[l++]=i.attenuationColor.g,g[l++]=i.attenuationColor.b):(g[l++]=1,g[l++]=1,g[l++]=1),g[l++]=r(i,"attenuationDistance",1/0),g[l++]=n(i,"alphaMap"),g[l++]=i.opacity,g[l++]=i.alphaTest,!u&&i.transmission>0)g[l++]=0;else switch(i.side){case a.FrontSide:g[l++]=1;break;case a.BackSide:g[l++]=-1;break;case a.DoubleSide:g[l++]=0}l++,l++,g[l++]=Number(i.vertexColors)|Number(i.flatShading)<<1,g[l++]=Number(i.transparent),l+=s(i,"map",g,l),l+=s(i,"metalnessMap",g,l),l+=s(i,"roughnessMap",g,l),l+=s(i,"transmissionMap",g,l),l+=s(i,"emissiveMap",g,l),l+=s(i,"normalMap",g,l),l+=s(i,"clearcoatMap",g,l),l+=s(i,"clearcoatNormalMap",g,l),l+=s(i,"clearcoatRoughnessMap",g,l),l+=s(i,"sheenColorMap",g,l),l+=s(i,"sheenRoughnessMap",g,l),l+=s(i,"iridescenceMap",g,l),l+=s(i,"iridescenceThicknessMap",g,l),l+=s(i,"specularColorMap",g,l),l+=s(i,"specularIntensityMap",g,l)}this.needsUpdate=!0}}})),r.register("kOapr",(function(e,n){function a(t){return`${t.source.uuid}:${t.encoding}`}function r(t){const e=new Set,n=[];for(let r=0,i=t.length;r<i;r++){const i=t[r],o=a(i);e.has(o)||(e.add(o),n.push(i))}return n}t(e.exports,"getTextureHash",(()=>a)),t(e.exports,"reduceTexturesToUniqueSources",(()=>r))})),r.register("12pjC",(function(e,n){t(e.exports,"RenderTarget2DArray",(()=>l));var a=r("ilwiq"),i=r("RPVlj"),o=r("kOapr");const s=new a.Color;class l extends a.WebGLArrayRenderTarget{constructor(...t){super(...t);const e=this.texture;e.format=a.RGBAFormat,e.type=a.UnsignedByteType,e.minFilter=a.LinearFilter,e.magFilter=a.LinearFilter,e.wrapS=a.RepeatWrapping,e.wrapT=a.RepeatWrapping,e.setTextures=(...t)=>{this.setTextures(...t)};const n=new i.FullScreenQuad(new a.MeshBasicMaterial);this.fsQuad=n}setTextures(t,e,n,r){const i=o.reduceTexturesToUniqueSources(r),l=t.getRenderTarget(),c=t.toneMapping,u=t.getClearAlpha();t.getClearColor(s);const f=i.length||1;this.setSize(e,n,f),t.setClearColor(0,0),t.toneMapping=a.NoToneMapping;const h=this.fsQuad;for(let e=0,n=f;e<n;e++){const n=i[e];n&&(n.matrixAutoUpdate=!1,n.matrix.identity(),h.material.map=n,h.material.transparent=!0,t.setRenderTarget(this,e),h.render(t),n.updateMatrix(),n.matrixAutoUpdate=!0)}h.material.map=null,t.setClearColor(s,u),t.setRenderTarget(l),t.toneMapping=c}dispose(){super.dispose(),this.fsQuad.dispose()}}})),r.register("ejeD6",(function(e,n){t(e.exports,"cameraStructGLSL",(()=>a));const a="\n\n\tstruct PhysicalCamera {\n\n\t\tfloat focusDistance;\n\t\tfloat anamorphicRatio;\n\t\tfloat bokehSize;\n\t\tint apertureBlades;\n\t\tfloat apertureRotation;\n\n\t};\n\n"})),r.register("7Ee23",(function(e,n){t(e.exports,"equirectStructGLSL",(()=>a));const a="\n\n\tstruct EquirectHdrInfo {\n\n\t\tsampler2D marginalWeights;\n\t\tsampler2D conditionalWeights;\n\t\tsampler2D map;\n\n\t\tfloat totalSumWhole;\n\t\tfloat totalSumDecimal;\n\n\t};\n\n"})),r.register("euxcz",(function(e,n){t(e.exports,"lightsStructGLSL",(()=>a));const a="\n\n\t#define RECT_AREA_LIGHT_TYPE 0\n\t#define CIRC_AREA_LIGHT_TYPE 1\n\t#define SPOT_LIGHT_TYPE 2\n\t#define DIR_LIGHT_TYPE 3\n\t#define POINT_LIGHT_TYPE 4\n\n\tstruct LightsInfo {\n\n\t\tsampler2D tex;\n\t\tuint count;\n\n\t};\n\n\tstruct Light {\n\n\t\tvec3 position;\n\t\tint type;\n\n\t\tvec3 color;\n\t\tfloat intensity;\n\n\t\tvec3 u;\n\t\tvec3 v;\n\t\tfloat area;\n\n\t\t// spot light fields\n\t\tfloat radius;\n\t\tfloat near;\n\t\tfloat decay;\n\t\tfloat distance;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint iesProfile;\n\n\t};\n\n\tLight readLightInfo( sampler2D tex, uint index ) {\n\n\t\tuint i = index * 6u;\n\n\t\tvec4 s0 = texelFetch1D( tex, i + 0u );\n\t\tvec4 s1 = texelFetch1D( tex, i + 1u );\n\t\tvec4 s2 = texelFetch1D( tex, i + 2u );\n\t\tvec4 s3 = texelFetch1D( tex, i + 3u );\n\n\t\tLight l;\n\t\tl.position = s0.rgb;\n\t\tl.type = int( round( s0.a ) );\n\n\t\tl.color = s1.rgb;\n\t\tl.intensity = s1.a;\n\n\t\tl.u = s2.rgb;\n\t\tl.v = s3.rgb;\n\t\tl.area = s3.a;\n\n\t\tif ( l.type == SPOT_LIGHT_TYPE || l.type == POINT_LIGHT_TYPE ) {\n\n\t\t\tvec4 s4 = texelFetch1D( tex, i + 4u );\n\t\t\tvec4 s5 = texelFetch1D( tex, i + 5u );\n\t\t\tl.radius = s4.r;\n\t\t\tl.near = s4.g;\n\t\t\tl.decay = s4.b;\n\t\t\tl.distance = s4.a;\n\n\t\t\tl.coneCos = s5.r;\n\t\t\tl.penumbraCos = s5.g;\n\t\t\tl.iesProfile = int( round ( s5.b ) );\n\n\t\t}\n\n\t\treturn l;\n\n\t}\n\n"})),r.register("azDH8",(function(e,n){t(e.exports,"fogMaterialBvhGLSL",(()=>a));const a="\n\n#ifndef FOG_CHECK_ITERATIONS\n#define FOG_CHECK_ITERATIONS 30\n#endif\n\n// returns whether the given material is a fog material or not\nbool isMaterialFogVolume( sampler2D materials, uint materialIndex ) {\n\n\tuint i = materialIndex * 45u;\n\tvec4 s14 = texelFetch1D( materials, i + 14u );\n\treturn bool( int( s14.b ) & 4 );\n\n}\n\n// returns true if we're within the first fog volume we hit\nbool bvhIntersectFogVolumeHit(\n\tBVH bvh, vec3 rayOrigin, vec3 rayDirection,\n\tusampler2D materialIndexAttribute, sampler2D materials,\n\tout Material material\n) {\n\n\tmaterial.fogVolume = false;\n\n\tfor ( int i = 0; i < FOG_CHECK_ITERATIONS; i ++ ) {\n\n\t\t// find nearest hit\n\t\tuvec4 faceIndices = uvec4( 0u );\n\t\tvec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\n\t\tvec3 barycoord = vec3( 0.0 );\n\t\tfloat side = 1.0;\n\t\tfloat dist = 0.0;\n\t\tbool hit = bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist );\n\t\tif ( hit ) {\n\n\t\t\t// if it's a fog volume return whether we hit the front or back face\n\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, faceIndices.x ).r;\n\t\t\tif ( isMaterialFogVolume( materials, materialIndex ) ) {\n\n\t\t\t\tmaterial = readMaterialInfo( materials, materialIndex );\n\t\t\t\treturn side == - 1.0;\n\n\t\t\t} else {\n\n\t\t\t\t// move the ray forward\n\t\t\t\trayOrigin = stepRayOrigin( rayOrigin, rayDirection, - faceNormal, dist );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\n"})),r.register("614HA",(function(e,n){t(e.exports,"bsdfSamplingGLSL",(()=>s));var a=r("bkGXj"),i=r("eqUxc"),o=r("afkdx");const s=`\n\n\tstruct SurfaceRecord {\n\n\t\t// surface type\n\t\tbool volumeParticle;\n\n\t\t// geometry\n\t\tvec3 faceNormal;\n\t\tbool frontFace;\n\t\tvec3 normal;\n\n\t\t// cached properties\n\t\tfloat eta;\n\t\tfloat f0;\n\n\t\t// material\n\t\tfloat roughness;\n\t\tfloat filteredRoughness;\n\t\tfloat metalness;\n\t\tvec3 color;\n\t\tvec3 emission;\n\n\t\t// transmission\n\t\tfloat ior;\n\t\tfloat transmission;\n\t\tbool thinFilm;\n\t\tvec3 attenuationColor;\n\t\tfloat attenuationDistance;\n\n\t\t// clearcoat\n\t\tvec3 clearcoatNormal;\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tfloat filteredClearcoatRoughness;\n\n\t\t// sheen\n\t\tfloat sheen;\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\n\t\t// iridescence\n\t\tfloat iridescence;\n\t\tfloat iridescenceIor;\n\t\tfloat iridescenceThickness;\n\n\t\t// specular\n\t\tvec3 specularColor;\n\t\tfloat specularIntensity;\n\t};\n\n\tstruct ScatterRecord {\n\t\tfloat specularPdf;\n\t\tfloat pdf;\n\n\t\tvec3 direction;\n\t\tvec3 clearcoatDirection;\n\n\t\tvec3 color;\n\t};\n\n\t${a.ggxGLSL}\n\t${i.sheenGLSL}\n\t${o.iridescenceGLSL}\n\n\t// diffuse\n\tfloat diffuseEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, out vec3 color ) {\n\n\t\t// https://schuttejoe.github.io/post/disneybsdf/\n\t\tfloat fl = schlickFresnel( wi.z, 0.0 );\n\t\tfloat fv = schlickFresnel( wo.z, 0.0 );\n\n\t\tfloat metalFactor = ( 1.0 - surf.metalness );\n\t\tfloat transFactor = ( 1.0 - surf.transmission );\n\t\tfloat rr = 0.5 + 2.0 * surf.roughness * fl * fl;\n\t\tfloat retro = rr * ( fl + fv + fl * fv * ( rr - 1.0f ) );\n\t\tfloat lambert = ( 1.0f - 0.5f * fl ) * ( 1.0f - 0.5f * fv );\n\n\t\t// TODO: subsurface approx?\n\n\t\tfloat F = evaluateFresnelWeight( dot( wo, wh ), surf.eta, surf.f0 );\n\t\tcolor = ( 1.0 - F ) * transFactor * metalFactor * wi.z * surf.color * ( retro + lambert ) / PI;\n\t\treturn wi.z / PI;\n\n\t}\n\n\tvec3 diffuseDirection( vec3 wo, SurfaceRecord surf ) {\n\n\t\tvec3 lightDirection = sampleSphere( sobol2( 11 ) );\n\t\tlightDirection.z += 1.0;\n\t\tlightDirection = normalize( lightDirection );\n\n\t\treturn lightDirection;\n\n\t}\n\n\t// specular\n\tfloat specularEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, out vec3 color ) {\n\n\t\t// if roughness is set to 0 then D === NaN which results in black pixels\n\t\tfloat metalness = surf.metalness;\n\t\tfloat roughness = surf.filteredRoughness;\n\n\t\tfloat eta = surf.eta;\n\t\tfloat f0 = surf.f0;\n\n\t\tvec3 f0Color = mix( f0 * surf.specularColor * surf.specularIntensity, surf.color, surf.metalness );\n\t\tvec3 f90Color = vec3( mix( surf.specularIntensity, 1.0, surf.metalness ) );\n\t\tvec3 F = evaluateFresnel( dot( wo, wh ), eta, f0Color, f90Color );\n\n\t\tvec3 iridescenceF = evalIridescence( 1.0, surf.iridescenceIor, dot( wi, wh ), surf.iridescenceThickness, f0Color );\n\t\tF = mix( F, iridescenceF,  surf.iridescence );\n\n\t\t// PDF\n\t\t// See 14.1.1 Microfacet BxDFs in https://www.pbr-book.org/\n\t\tfloat incidentTheta = acos( wo.z );\n\t\tfloat G = ggxShadowMaskG2( wi, wo, roughness );\n\t\tfloat D = ggxDistribution( wh, roughness );\n\t\tfloat G1 = ggxShadowMaskG1( incidentTheta, roughness );\n\t\tfloat ggxPdf = D * G1 * max( 0.0, abs( dot( wo, wh ) ) ) / abs ( wo.z );\n\n\t\tcolor = wi.z * F * G * D / ( 4.0 * abs( wi.z * wo.z ) );\n\t\treturn ggxPdf / ( 4.0 * dot( wo, wh ) );\n\n\t}\n\n\tvec3 specularDirection( vec3 wo, SurfaceRecord surf ) {\n\n\t\t// sample ggx vndf distribution which gives a new normal\n\t\tfloat roughness = surf.filteredRoughness;\n\t\tvec3 halfVector = ggxDirection(\n\t\t\two,\n\t\t\tvec2( roughness ),\n\t\t\tsobol2( 12 )\n\t\t);\n\n\t\t// apply to new ray by reflecting off the new normal\n\t\treturn - reflect( wo, halfVector );\n\n\t}\n\n\n\t// transmission\n\t/*\n\tfloat transmissionEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, out vec3 color ) {\n\n\t\t// See section 4.2 in https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n\n\t\tfloat filteredRoughness = surf.filteredRoughness;\n\t\tfloat eta = surf.eta;\n\t\tbool frontFace = surf.frontFace;\n\t\tbool thinFilm = surf.thinFilm;\n\n\t\tcolor = surf.transmission * surf.color;\n\n\t\tfloat denom = pow( eta * dot( wi, wh ) + dot( wo, wh ), 2.0 );\n\t\treturn ggxPDF( wo, wh, filteredRoughness ) / denom;\n\n\t}\n\n\tvec3 transmissionDirection( vec3 wo, SurfaceRecord surf ) {\n\n\t\tfloat filteredRoughness = surf.filteredRoughness;\n\t\tfloat eta = surf.eta;\n\t\tbool frontFace = surf.frontFace;\n\n\t\t// sample ggx vndf distribution which gives a new normal\n\t\tvec3 halfVector = ggxDirection(\n\t\t\two,\n\t\t\tvec2( filteredRoughness ),\n\t\t\tsobol2( 13 )\n\t\t);\n\n\t\tvec3 lightDirection = refract( normalize( - wo ), halfVector, eta );\n\t\tif ( surf.thinFilm ) {\n\n\t\t\tlightDirection = - refract( normalize( - lightDirection ), - vec3( 0.0, 0.0, 1.0 ), 1.0 / eta );\n\n\t\t}\n\n\t\treturn normalize( lightDirection );\n\n\t}\n\t*/\n\n\t// TODO: This is just using a basic cosine-weighted specular distribution with an\n\t// incorrect PDF value at the moment. Update it to correctly use a GGX distribution\n\tfloat transmissionEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, out vec3 color ) {\n\n\t\tcolor = surf.transmission * surf.color;\n\n\t\t// PDF\n\t\tfloat F = evaluateFresnelWeight( dot( wo, wh ), surf.eta, surf.f0 );\n\t\tif ( F >= 1.0 ) {\n\n\t\t\treturn 0.0;\n\n\t\t}\n\n\t\treturn 1.0 / ( 1.0 - F );\n\n\t}\n\n\tvec3 transmissionDirection( vec3 wo, SurfaceRecord surf ) {\n\n\t\tfloat roughness = surf.filteredRoughness;\n\t\tfloat eta = surf.eta;\n\t\tvec3 halfVector = normalize( vec3( 0.0, 0.0, 1.0 ) + sampleSphere( sobol2( 13 ) ) * roughness );\n\t\tvec3 lightDirection = refract( normalize( - wo ), halfVector, eta );\n\n\t\tif ( surf.thinFilm ) {\n\n\t\t\tlightDirection = - refract( normalize( - lightDirection ), - vec3( 0.0, 0.0, 1.0 ), 1.0 / eta );\n\n\t\t}\n\t\treturn normalize( lightDirection );\n\n\t}\n\n\t// clearcoat\n\tfloat clearcoatEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, inout vec3 color ) {\n\n\t\tfloat ior = 1.5;\n\t\tfloat f0 = iorRatioToF0( ior );\n\t\tbool frontFace = surf.frontFace;\n\t\tfloat roughness = surf.filteredClearcoatRoughness;\n\n\t\tfloat eta = frontFace ? 1.0 / ior : ior;\n\t\tfloat G = ggxShadowMaskG2( wi, wo, roughness );\n\t\tfloat D = ggxDistribution( wh, roughness );\n\t\tfloat F = schlickFresnel( dot( wi, wh ), f0 );\n\n\t\tfloat fClearcoat = F * D * G / ( 4.0 * abs( wi.z * wo.z ) );\n\t\tcolor = color * ( 1.0 - surf.clearcoat * F ) + fClearcoat * surf.clearcoat * wi.z;\n\n\t\t// PDF\n\t\t// See equation (27) in http://jcgt.org/published/0003/02/03/\n\t\treturn ggxPDF( wo, wh, roughness ) / ( 4.0 * dot( wi, wh ) );\n\n\t}\n\n\tvec3 clearcoatDirection( vec3 wo, SurfaceRecord surf ) {\n\n\t\t// sample ggx vndf distribution which gives a new normal\n\t\tfloat roughness = surf.filteredClearcoatRoughness;\n\t\tvec3 halfVector = ggxDirection(\n\t\t\two,\n\t\t\tvec2( roughness ),\n\t\t\tsobol2( 14 )\n\t\t);\n\n\t\t// apply to new ray by reflecting off the new normal\n\t\treturn - reflect( wo, halfVector );\n\n\t}\n\n\t// sheen\n\tvec3 sheenColor( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf ) {\n\n\t\tfloat cosThetaO = saturateCos( wo.z );\n\t\tfloat cosThetaI = saturateCos( wi.z );\n\t\tfloat cosThetaH = wh.z;\n\n\t\tfloat D = velvetD( cosThetaH, surf.sheenRoughness );\n\t\tfloat G = velvetG( cosThetaO, cosThetaI, surf.sheenRoughness );\n\n\t\t// See equation (1) in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\n\t\tvec3 color = surf.sheenColor;\n\t\tcolor *= D * G / ( 4.0 * abs( cosThetaO * cosThetaI ) );\n\t\tcolor *= wi.z;\n\n\t\treturn color;\n\n\t}\n\n\t// bsdf\n\tvoid getLobeWeights(\n\t\tvec3 wo, vec3 wi, vec3 wh, vec3 clearcoatWo, SurfaceRecord surf,\n\t\tout float diffuseWeight, out float specularWeight, out float transmissionWeight, out float clearcoatWeight\n\t) {\n\n\t\tfloat metalness = surf.metalness;\n\t\tfloat transmission = surf.transmission;\n\t\tfloat fEstimate = evaluateFresnelWeight( dot( wo, wh ), surf.eta, surf.f0 );\n\n\t\tfloat transSpecularProb = mix( max( 0.25, fEstimate ), 1.0, metalness );\n\t\tfloat diffSpecularProb = 0.5 + 0.5 * metalness;\n\n\t\tdiffuseWeight = ( 1.0 - transmission ) * ( 1.0 - diffSpecularProb );\n\t\tspecularWeight = transmission * transSpecularProb + ( 1.0 - transmission ) * diffSpecularProb;\n\t\ttransmissionWeight = transmission * ( 1.0 - transSpecularProb );\n\t\tclearcoatWeight = surf.clearcoat * schlickFresnel( clearcoatWo.z, 0.04 );\n\n\t\tfloat totalWeight = diffuseWeight + specularWeight + transmissionWeight + clearcoatWeight;\n\t\tdiffuseWeight /= totalWeight;\n\t\tspecularWeight /= totalWeight;\n\t\ttransmissionWeight /= totalWeight;\n\t\tclearcoatWeight /= totalWeight;\n\t}\n\n\tfloat bsdfEval(\n\t\tvec3 wo, vec3 clearcoatWo, vec3 wi, vec3 clearcoatWi, SurfaceRecord surf,\n\t\tfloat diffuseWeight, float specularWeight, float transmissionWeight, float clearcoatWeight, out float specularPdf, out vec3 color\n\t) {\n\n\t\tfloat metalness = surf.metalness;\n\t\tfloat transmission = surf.transmission;\n\n\t\tfloat spdf = 0.0;\n\t\tfloat dpdf = 0.0;\n\t\tfloat tpdf = 0.0;\n\t\tfloat cpdf = 0.0;\n\t\tcolor = vec3( 0.0 );\n\n\t\tvec3 halfVector = getHalfVector( wi, wo, surf.eta );\n\n\t\t// diffuse\n\t\tif ( diffuseWeight > 0.0 && wi.z > 0.0 ) {\n\n\t\t\tdpdf = diffuseEval( wo, wi, halfVector, surf, color );\n\t\t\tcolor *= 1.0 - surf.transmission;\n\n\t\t}\n\n\t\t// ggx specular\n\t\tif ( specularWeight > 0.0 && wi.z > 0.0 ) {\n\n\t\t\tvec3 outColor;\n\t\t\tspdf = specularEval( wo, wi, getHalfVector( wi, wo ), surf, outColor );\n\t\t\tcolor += outColor;\n\n\t\t}\n\n\t\t// transmission\n\t\tif ( transmissionWeight > 0.0 && wi.z < 0.0 ) {\n\n\t\t\ttpdf = transmissionEval( wo, wi, halfVector, surf, color );\n\n\t\t}\n\n\t\t// sheen\n\t\tcolor *= mix( 1.0, sheenAlbedoScaling( wo, wi, surf ), surf.sheen );\n\t\tcolor += sheenColor( wo, wi, halfVector, surf ) * surf.sheen;\n\n\t\t// clearcoat\n\t\tif ( clearcoatWi.z >= 0.0 && clearcoatWeight > 0.0 ) {\n\n\t\t\tvec3 clearcoatHalfVector = getHalfVector( clearcoatWo, clearcoatWi );\n\t\t\tcpdf = clearcoatEval( clearcoatWo, clearcoatWi, clearcoatHalfVector, surf, color );\n\n\t\t}\n\n\t\tfloat pdf =\n\t\t\tdpdf * diffuseWeight\n\t\t\t+ spdf * specularWeight\n\t\t\t+ tpdf * transmissionWeight\n\t\t\t+ cpdf * clearcoatWeight;\n\n\t\t// retrieve specular rays for the shadows flag\n\t\tspecularPdf = spdf * specularWeight + cpdf * clearcoatWeight;\n\n\t\treturn pdf;\n\n\t}\n\n\tfloat bsdfResult( vec3 wo, vec3 clearcoatWo, vec3 wi, vec3 clearcoatWi, SurfaceRecord surf, out vec3 color ) {\n\n\t\tif ( surf.volumeParticle ) {\n\n\t\t\tcolor = surf.color / ( 4.0 * PI );\n\t\t\treturn 1.0 / ( 4.0 * PI );\n\n\t\t}\n\n\t\tvec3 wh = getHalfVector( wo, wi, surf.eta );\n\t\tfloat diffuseWeight;\n\t\tfloat specularWeight;\n\t\tfloat transmissionWeight;\n\t\tfloat clearcoatWeight;\n\t\tgetLobeWeights( wo, wi, wh, clearcoatWo, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight );\n\n\t\tfloat specularPdf;\n\t\treturn bsdfEval( wo, clearcoatWo, wi, clearcoatWi, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight, specularPdf, color );\n\n\t}\n\n\tScatterRecord bsdfSample( vec3 wo, vec3 clearcoatWo, mat3 normalBasis, mat3 invBasis, mat3 clearcoatNormalBasis, mat3 clearcoatInvBasis, SurfaceRecord surf ) {\n\n\t\tif ( surf.volumeParticle ) {\n\n\t\t\tvec3 wi = sampleSphere( sobol2( 16 ) );\n\t\t\tvec3 wh = normalize( wo + wi );\n\n\t\t\tScatterRecord sampleRec;\n\t\t\tsampleRec.specularPdf = 0.0;\n\t\t\tsampleRec.pdf = 1.0 / ( 4.0 * PI );\n\t\t\tsampleRec.direction = wi;\n\t\t\tsampleRec.clearcoatDirection = wi;\n\t\t\tsampleRec.color = surf.color / ( 4.0 * PI );\n\t\t\treturn sampleRec;\n\n\t\t}\n\n\t\tfloat diffuseWeight;\n\t\tfloat specularWeight;\n\t\tfloat transmissionWeight;\n\t\tfloat clearcoatWeight;\n\t\t// using normal and basically-reflected ray since we don't have proper half vector here\n\t\tgetLobeWeights( wo, wo, vec3( 0, 0, 1 ), clearcoatWo, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight );\n\n\t\tfloat pdf[4];\n\t\tpdf[0] = diffuseWeight;\n\t\tpdf[1] = specularWeight;\n\t\tpdf[2] = transmissionWeight;\n\t\tpdf[3] = clearcoatWeight;\n\n\t\tfloat cdf[4];\n\t\tcdf[0] = pdf[0];\n\t\tcdf[1] = pdf[1] + cdf[0];\n\t\tcdf[2] = pdf[2] + cdf[1];\n\t\tcdf[3] = pdf[3] + cdf[2];\n\n\t\tif( cdf[3] != 0.0 ) {\n\n\t\t\tfloat invMaxCdf = 1.0 / cdf[3];\n\t\t\tcdf[0] *= invMaxCdf;\n\t\t\tcdf[1] *= invMaxCdf;\n\t\t\tcdf[2] *= invMaxCdf;\n\t\t\tcdf[3] *= invMaxCdf;\n\n\t\t} else {\n\n\t\t\tcdf[0] = 1.0;\n\t\t\tcdf[1] = 0.0;\n\t\t\tcdf[2] = 0.0;\n\t\t\tcdf[3] = 0.0;\n\n\t\t}\n\n\t\tvec3 wi;\n\t\tvec3 clearcoatWi;\n\n\t\tfloat r = sobol( 15 );\n\t\tif ( r <= cdf[0] ) { // diffuse\n\n\t\t\twi = diffuseDirection( wo, surf );\n\t\t\tclearcoatWi = normalize( clearcoatInvBasis * normalize( normalBasis * wi ) );\n\n\t\t} else if ( r <= cdf[1] ) { // specular\n\n\t\t\twi = specularDirection( wo, surf );\n\t\t\tclearcoatWi = normalize( clearcoatInvBasis * normalize( normalBasis * wi ) );\n\n\t\t} else if ( r <= cdf[2] ) { // transmission / refraction\n\n\t\t\twi = transmissionDirection( wo, surf );\n\t\t\tclearcoatWi = normalize( clearcoatInvBasis * normalize( normalBasis * wi ) );\n\n\t\t} else if ( r <= cdf[3] ) { // clearcoat\n\n\t\t\tclearcoatWi = clearcoatDirection( clearcoatWo, surf );\n\t\t\twi = normalize( invBasis * normalize( clearcoatNormalBasis * clearcoatWi ) );\n\n\t\t}\n\n\t\tScatterRecord result;\n\t\tresult.pdf = bsdfEval( wo, clearcoatWo, wi, clearcoatWi, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight, result.specularPdf, result.color );\n\t\tresult.direction = wi;\n\t\tresult.clearcoatDirection = clearcoatWi;\n\n\t\treturn result;\n\n\t}\n\n`})),r.register("bkGXj",(function(e,n){t(e.exports,"ggxGLSL",(()=>a));const a="\n\n\t// The GGX functions provide sampling and distribution information for normals as output so\n\t// in order to get probability of scatter direction the half vector must be computed and provided.\n\t// [0] https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n\t// [1] https://hal.archives-ouvertes.fr/hal-01509746/document\n\t// [2] http://jcgt.org/published/0007/04/01/\n\t// [4] http://jcgt.org/published/0003/02/03/\n\n\t// trowbridge-reitz === GGX === GTR\n\n\tvec3 ggxDirection( vec3 incidentDir, vec2 roughness, vec2 uv ) {\n\n\t\t// TODO: try GGXVNDF implementation from reference [2], here. Needs to update ggxDistribution\n\t\t// function below, as well\n\n\t\t// Implementation from reference [1]\n\t\t// stretch view\n\t\tvec3 V = normalize( vec3( roughness * incidentDir.xy, incidentDir.z ) );\n\n\t\t// orthonormal basis\n\t\tvec3 T1 = ( V.z < 0.9999 ) ? normalize( cross( V, vec3( 0.0, 0.0, 1.0 ) ) ) : vec3( 1.0, 0.0, 0.0 );\n\t\tvec3 T2 = cross( T1, V );\n\n\t\t// sample point with polar coordinates (r, phi)\n\t\tfloat a = 1.0 / ( 1.0 + V.z );\n\t\tfloat r = sqrt( uv.x );\n\t\tfloat phi = ( uv.y < a ) ? uv.y / a * PI : PI + ( uv.y - a ) / ( 1.0 - a ) * PI;\n\t\tfloat P1 = r * cos( phi );\n\t\tfloat P2 = r * sin( phi ) * ( ( uv.y < a ) ? 1.0 : V.z );\n\n\t\t// compute normal\n\t\tvec3 N = P1 * T1 + P2 * T2 + V * sqrt( max( 0.0, 1.0 - P1 * P1 - P2 * P2 ) );\n\n\t\t// unstretch\n\t\tN = normalize( vec3( roughness * N.xy, max( 0.0, N.z ) ) );\n\n\t\treturn N;\n\n\t}\n\n\t// Below are PDF and related functions for use in a Monte Carlo path tracer\n\t// as specified in Appendix B of the following paper\n\t// See equation (34) from reference [0]\n\tfloat ggxLamda( float theta, float roughness ) {\n\n\t\tfloat tanTheta = tan( theta );\n\t\tfloat tanTheta2 = tanTheta * tanTheta;\n\t\tfloat alpha2 = roughness * roughness;\n\n\t\tfloat numerator = - 1.0 + sqrt( 1.0 + alpha2 * tanTheta2 );\n\t\treturn numerator / 2.0;\n\n\t}\n\n\t// See equation (34) from reference [0]\n\tfloat ggxShadowMaskG1( float theta, float roughness ) {\n\n\t\treturn 1.0 / ( 1.0 + ggxLamda( theta, roughness ) );\n\n\t}\n\n\t// See equation (125) from reference [4]\n\tfloat ggxShadowMaskG2( vec3 wi, vec3 wo, float roughness ) {\n\n\t\tfloat incidentTheta = acos( wi.z );\n\t\tfloat scatterTheta = acos( wo.z );\n\t\treturn 1.0 / ( 1.0 + ggxLamda( incidentTheta, roughness ) + ggxLamda( scatterTheta, roughness ) );\n\n\t}\n\n\t// See equation (33) from reference [0]\n\tfloat ggxDistribution( vec3 halfVector, float roughness ) {\n\n\t\tfloat a2 = roughness * roughness;\n\t\ta2 = max( EPSILON, a2 );\n\t\tfloat cosTheta = halfVector.z;\n\t\tfloat cosTheta4 = pow( cosTheta, 4.0 );\n\n\t\tif ( cosTheta == 0.0 ) return 0.0;\n\n\t\tfloat theta = acosSafe( halfVector.z );\n\t\tfloat tanTheta = tan( theta );\n\t\tfloat tanTheta2 = pow( tanTheta, 2.0 );\n\n\t\tfloat denom = PI * cosTheta4 * pow( a2 + tanTheta2, 2.0 );\n\t\treturn ( a2 / denom );\n\n\t}\n\n\t// See equation (3) from reference [2]\n\tfloat ggxPDF( vec3 wi, vec3 halfVector, float roughness ) {\n\n\t\tfloat incidentTheta = acos( wi.z );\n\t\tfloat D = ggxDistribution( halfVector, roughness );\n\t\tfloat G1 = ggxShadowMaskG1( incidentTheta, roughness );\n\n\t\treturn D * G1 * max( 0.0, dot( wi, halfVector ) ) / wi.z;\n\n\t}\n\n"})),r.register("eqUxc",(function(e,n){t(e.exports,"sheenGLSL",(()=>a));const a="\n\n\t// See equation (2) in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\n\tfloat velvetD( float cosThetaH, float roughness ) {\n\n\t\tfloat alpha = max( roughness, 0.07 );\n\t\talpha = alpha * alpha;\n\n\t\tfloat invAlpha = 1.0 / alpha;\n\n\t\tfloat sqrCosThetaH = cosThetaH * cosThetaH;\n\t\tfloat sinThetaH = max( 1.0 - sqrCosThetaH, 0.001 );\n\n\t\treturn ( 2.0 + invAlpha ) * pow( sinThetaH, 0.5 * invAlpha ) / ( 2.0 * PI );\n\n\t}\n\n\tfloat velvetParamsInterpolate( int i, float oneMinusAlphaSquared ) {\n\n\t\tconst float p0[5] = float[5]( 25.3245, 3.32435, 0.16801, -1.27393, -4.85967 );\n\t\tconst float p1[5] = float[5]( 21.5473, 3.82987, 0.19823, -1.97760, -4.32054 );\n\n\t\treturn mix( p1[i], p0[i], oneMinusAlphaSquared );\n\n\t}\n\n\tfloat velvetL( float x, float alpha ) {\n\n\t\tfloat oneMinusAlpha = 1.0 - alpha;\n\t\tfloat oneMinusAlphaSquared = oneMinusAlpha * oneMinusAlpha;\n\n\t\tfloat a = velvetParamsInterpolate( 0, oneMinusAlphaSquared );\n\t\tfloat b = velvetParamsInterpolate( 1, oneMinusAlphaSquared );\n\t\tfloat c = velvetParamsInterpolate( 2, oneMinusAlphaSquared );\n\t\tfloat d = velvetParamsInterpolate( 3, oneMinusAlphaSquared );\n\t\tfloat e = velvetParamsInterpolate( 4, oneMinusAlphaSquared );\n\n\t\treturn a / ( 1.0 + b * pow( abs( x ), c ) ) + d * x + e;\n\n\t}\n\n\t// See equation (3) in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\n\tfloat velvetLambda( float cosTheta, float alpha ) {\n\n\t\treturn abs( cosTheta ) < 0.5 ? exp( velvetL( cosTheta, alpha ) ) : exp( 2.0 * velvetL( 0.5, alpha ) - velvetL( 1.0 - cosTheta, alpha ) );\n\n\t}\n\n\t// See Section 3, Shadowing Term, in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\n\tfloat velvetG( float cosThetaO, float cosThetaI, float roughness ) {\n\n\t\tfloat alpha = max( roughness, 0.07 );\n\t\talpha = alpha * alpha;\n\n\t\treturn 1.0 / ( 1.0 + velvetLambda( cosThetaO, alpha ) + velvetLambda( cosThetaI, alpha ) );\n\n\t}\n\n\tfloat directionalAlbedoSheen( float cosTheta, float alpha ) {\n\n\t\tcosTheta = saturate( cosTheta );\n\n\t\tfloat c = 1.0 - cosTheta;\n\t\tfloat c3 = c * c * c;\n\n\t\treturn 0.65584461 * c3 + 1.0 / ( 4.16526551 + exp( -7.97291361 * sqrt( alpha ) + 6.33516894 ) );\n\n\t}\n\n\tfloat sheenAlbedoScaling( vec3 wo, vec3 wi, SurfaceRecord surf ) {\n\n\t\tfloat alpha = max( surf.sheenRoughness, 0.07 );\n\t\talpha = alpha * alpha;\n\n\t\tfloat maxSheenColor = max( max( surf.sheenColor.r, surf.sheenColor.g ), surf.sheenColor.b );\n\n\t\tfloat eWo = directionalAlbedoSheen( saturateCos( wo.z ), alpha );\n\t\tfloat eWi = directionalAlbedoSheen( saturateCos( wi.z ), alpha );\n\n\t\treturn min( 1.0 - maxSheenColor * eWo, 1.0 - maxSheenColor * eWi );\n\n\t}\n\n\t// See Section 5, Layering, in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\n\tfloat sheenAlbedoScaling( vec3 wo, SurfaceRecord surf ) {\n\n\t\tfloat alpha = max( surf.sheenRoughness, 0.07 );\n\t\talpha = alpha * alpha;\n\n\t\tfloat maxSheenColor = max( max( surf.sheenColor.r, surf.sheenColor.g ), surf.sheenColor.b );\n\n\t\tfloat eWo = directionalAlbedoSheen( saturateCos( wo.z ), alpha );\n\n\t\treturn 1.0 - maxSheenColor * eWo;\n\n\t}\n\n"})),r.register("afkdx",(function(e,n){t(e.exports,"iridescenceGLSL",(()=>a));const a="\n\n\t// XYZ to sRGB color space\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\n\tvec3 fresnel0ToIor( vec3 fresnel0 ) {\n\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\n\t}\n\n\t// Conversion FO/IOR\n\tvec3 iorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\n\t\treturn square( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\n\t}\n\n\t// ior is a value between 1.0 and 3.0. 1.0 is air interface\n\tfloat iorToFresnel0( float transmittedIor, float incidentIor ) {\n\n\t\treturn square( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ) );\n\n\t}\n\n\t// Fresnel equations for dielectric/dielectric interfaces. See https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - square( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * square( phase ) );\n\t\txyz /= 1.0685e-7;\n\n\t\tvec3 srgb = XYZ_TO_REC709 * xyz;\n\t\treturn srgb;\n\n\t}\n\n\t// See Section 4. Analytic Spectral Integration, A Practical Extension to Microfacet Theory for the Modeling of Varying Iridescence, https://hal.archives-ouvertes.fr/hal-01518344/document\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\n\t\tvec3 I;\n\n\t\t// Force iridescenceIor -> outsideIOR when thinFilmThickness -> 0.0\n\t\tfloat iridescenceIor = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\n\t\t// Evaluate the cosTheta on the base layer (Snell law)\n\t\tfloat sinTheta2Sq = square( outsideIOR / iridescenceIor ) * ( 1.0 - square( cosTheta1 ) );\n\n\t\t// Handle TIR:\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\n\t\t\treturn vec3( 1.0 );\n\n\t\t}\n\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\n\t\t// First interface\n\t\tfloat R0 = iorToFresnel0( iridescenceIor, outsideIOR );\n\t\tfloat R12 = schlickFresnel( cosTheta1, R0 );\n\t\tfloat R21 = R12;\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIor < outsideIOR ) {\n\n\t\t\tphi12 = PI;\n\n\t\t}\n\n\t\tfloat phi21 = PI - phi12;\n\n\t\t// Second interface\n\t\tvec3 baseIOR = fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) ); // guard against 1.0\n\t\tvec3 R1 = iorToFresnel0( baseIOR, iridescenceIor );\n\t\tvec3 R23 = schlickFresnel( cosTheta2, R1 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[0] < iridescenceIor ) {\n\n\t\t\tphi23[ 0 ] = PI;\n\n\t\t}\n\n\t\tif ( baseIOR[1] < iridescenceIor ) {\n\n\t\t\tphi23[ 1 ] = PI;\n\n\t\t}\n\n\t\tif ( baseIOR[2] < iridescenceIor ) {\n\n\t\t\tphi23[ 2 ] = PI;\n\n\t\t}\n\n\t\t// Phase shift\n\t\tfloat OPD = 2.0 * iridescenceIor * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\n\t\t// Compound terms\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = square( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\n\t\t// Reflectance term for m = 0 (DC term amplitude)\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\n\t\t// Reflectance term for m > 0 (pairs of diracs)\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\n\t\t}\n\n\t\t// Since out of gamut colors might be produced, negative color values are clamped to 0.\n\t\treturn max( I, vec3( 0.0 ) );\n\n\t}\n\n"})),r.register("k3NkH",(function(e,n){t(e.exports,"fogGLSL",(()=>a));const a="\n\n\t// returns the hit distance given the material density\n\tfloat intersectFogVolume( Material material, float u ) {\n\n\t\t// https://raytracing.github.io/books/RayTracingTheNextWeek.html#volumes/constantdensitymediums\n\t\treturn material.opacity == 0.0 ? INFINITY : ( - 1.0 / material.opacity ) * log( u );\n\n\t}\n\n\tScatterRecord sampleFogVolume( SurfaceRecord surf, vec2 uv ) {\n\n\t\tScatterRecord sampleRec;\n\t\tsampleRec.specularPdf = 0.0;\n\t\tsampleRec.pdf = 1.0 / ( 2.0 * PI );\n\t\tsampleRec.direction = sampleSphere( uv );\n\t\tsampleRec.clearcoatDirection = sampleRec.direction;\n\t\tsampleRec.color = surf.color;\n\t\treturn sampleRec;\n\n\t}\n\n"})),r.register("a0p7X",(function(e,n){t(e.exports,"equirectSamplingGLSL",(()=>a));const a="\n\n\t// samples the the given environment map in the given direction\n\tvec3 sampleEquirectColor( sampler2D envMap, vec3 direction ) {\n\n\t\treturn texture2D( envMap, equirectDirectionToUv( direction ) ).rgb;\n\n\t}\n\n\t// gets the pdf of the given direction to sample\n\tfloat equirectDirectionPdf( vec3 direction ) {\n\n\t\tvec2 uv = equirectDirectionToUv( direction );\n\t\tfloat theta = uv.y * PI;\n\t\tfloat sinTheta = sin( theta );\n\t\tif ( sinTheta == 0.0 ) {\n\n\t\t\treturn 0.0;\n\n\t\t}\n\n\t\treturn 1.0 / ( 2.0 * PI * PI * sinTheta );\n\n\t}\n\n\t// samples the color given env map with CDF and returns the pdf of the direction\n\tfloat sampleEquirect( EquirectHdrInfo info, vec3 direction, out vec3 color ) {\n\n\t\tvec2 uv = equirectDirectionToUv( direction );\n\t\tcolor = texture2D( info.map, uv ).rgb;\n\n\t\tfloat totalSum = info.totalSumWhole + info.totalSumDecimal;\n\t\tfloat lum = luminance( color );\n\t\tivec2 resolution = textureSize( info.map, 0 );\n\t\tfloat pdf = lum / totalSum;\n\n\t\treturn float( resolution.x * resolution.y ) * pdf * equirectDirectionPdf( direction );\n\n\t}\n\n\t// samples a direction of the envmap with color and retrieves pdf\n\tfloat sampleEquirectProbability( EquirectHdrInfo info, vec2 r, out vec3 color, out vec3 direction ) {\n\n\t\t// sample env map cdf\n\t\tfloat v = texture2D( info.marginalWeights, vec2( r.x, 0.0 ) ).x;\n\t\tfloat u = texture2D( info.conditionalWeights, vec2( r.y, v ) ).x;\n\t\tvec2 uv = vec2( u, v );\n\n\t\tvec3 derivedDirection = equirectUvToDirection( uv );\n\t\tdirection = derivedDirection;\n\t\tcolor = texture2D( info.map, uv ).rgb;\n\n\t\tfloat totalSum = info.totalSumWhole + info.totalSumDecimal;\n\t\tfloat lum = luminance( color );\n\t\tivec2 resolution = textureSize( info.map, 0 );\n\t\tfloat pdf = lum / totalSum;\n\n\t\treturn float( resolution.x * resolution.y ) * pdf * equirectDirectionPdf( direction );\n\n\t}\n\n"})),r.register("6WG26",(function(e,n){t(e.exports,"lightSamplingGLSL",(()=>a));const a="\n\n\tfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\n\t\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n\n\t}\n\n\tfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\n\t\t// based upon Frostbite 3 Moving to Physically-based Rendering\n\t\t// page 32, equation 26: E[window1]\n\t\t// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), EPSILON );\n\n\t\tif ( cutoffDistance > 0.0 ) {\n\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\n\t\t}\n\n\t\treturn distanceFalloff;\n\n\t}\n\n\tfloat getPhotometricAttenuation( sampler2DArray iesProfiles, int iesProfile, vec3 posToLight, vec3 lightDir, vec3 u, vec3 v ) {\n\n\t\tfloat cosTheta = dot( posToLight, lightDir );\n\t\tfloat angle = acos( cosTheta ) * ( 1.0 / PI );\n\n\t\treturn texture2D( iesProfiles, vec3( 0.0, angle, iesProfile ) ).r;\n\n\t}\n\n\tstruct LightSampleRecord {\n\n\t\tfloat dist;\n\t\tvec3 direction;\n\t\tfloat pdf;\n\t\tvec3 emission;\n\t\tint type;\n\n\t};\n\n\tbool lightsClosestHit( sampler2D lights, uint lightCount, vec3 rayOrigin, vec3 rayDirection, out LightSampleRecord lightSampleRec ) {\n\n\t\tbool didHit = false;\n\t\tuint l;\n\t\tfor ( l = 0u; l < lightCount; l ++ ) {\n\n\t\t\tLight light = readLightInfo( lights, l );\n\n\t\t\tvec3 u = light.u;\n\t\t\tvec3 v = light.v;\n\n\t\t\t// check for backface\n\t\t\tvec3 normal = normalize( cross( u, v ) );\n\t\t\tif ( dot( normal, rayDirection ) < 0.0 ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tu *= 1.0 / dot( u, u );\n\t\t\tv *= 1.0 / dot( v, v );\n\n\t\t\tfloat dist;\n\n\t\t\t// MIS / light intersection is not supported for punctual lights.\n\t\t\tif(\n\t\t\t\t( light.type == RECT_AREA_LIGHT_TYPE && intersectsRectangle( light.position, normal, u, v, rayOrigin, rayDirection, dist ) ) ||\n\t\t\t\t( light.type == CIRC_AREA_LIGHT_TYPE && intersectsCircle( light.position, normal, u, v, rayOrigin, rayDirection, dist ) )\n\t\t\t) {\n\n\t\t\t\tif ( ! didHit || dist < lightSampleRec.dist ) {\n\n\t\t\t\t\tfloat cosTheta = dot( rayDirection, normal );\n\t\t\t\t\tdidHit = true;\n\t\t\t\t\tlightSampleRec.dist = dist;\n\t\t\t\t\tlightSampleRec.pdf = ( dist * dist ) / ( light.area * cosTheta );\n\t\t\t\t\tlightSampleRec.emission = light.color * light.intensity;\n\t\t\t\t\tlightSampleRec.direction = rayDirection;\n\t\t\t\t\tlightSampleRec.type = light.type;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn didHit;\n\n\t}\n\n\tLightSampleRecord randomAreaLightSample( Light light, vec3 rayOrigin, vec2 ruv ) {\n\n\t\tLightSampleRecord lightSampleRec;\n\t\tlightSampleRec.type = light.type;\n\n\t\tlightSampleRec.emission = light.color * light.intensity;\n\n\t\tvec3 randomPos;\n\t\tif( light.type == RECT_AREA_LIGHT_TYPE ) {\n\n\t\t\t// rectangular area light\n\t\t\trandomPos = light.position + light.u * ( ruv.x - 0.5 ) + light.v * ( ruv.y - 0.5 );\n\n\t\t} else if( light.type == CIRC_AREA_LIGHT_TYPE ) {\n\n\t\t\t// circular area light\n\t\t\tfloat r = 0.5 * sqrt( ruv.x );\n\t\t\tfloat theta = ruv.y * 2.0 * PI;\n\t\t\tfloat x = r * cos( theta );\n\t\t\tfloat y = r * sin( theta );\n\n\t\t\trandomPos = light.position + light.u * x + light.v * y;\n\n\t\t}\n\n\t\tvec3 toLight = randomPos - rayOrigin;\n\t\tfloat lightDistSq = dot( toLight, toLight );\n\t\tlightSampleRec.dist = sqrt( lightDistSq );\n\n\t\tvec3 direction = toLight / lightSampleRec.dist;\n\t\tlightSampleRec.direction = direction;\n\n\t\tvec3 lightNormal = normalize( cross( light.u, light.v ) );\n\t\tlightSampleRec.pdf = lightDistSq / ( light.area * dot( direction, lightNormal ) );\n\n\t\treturn lightSampleRec;\n\n\t}\n\n\tLightSampleRecord randomSpotLightSample( Light light, sampler2DArray iesProfiles, vec3 rayOrigin, vec2 ruv ) {\n\n\t\tfloat radius = light.radius * sqrt( ruv.x );\n\t\tfloat theta = ruv.y * 2.0 * PI;\n\t\tfloat x = radius * cos( theta );\n\t\tfloat y = radius * sin( theta );\n\n\t\tvec3 u = light.u;\n\t\tvec3 v = light.v;\n\t\tvec3 normal = normalize( cross( u, v ) );\n\n\t\tfloat angle = acos( light.coneCos );\n\t\tfloat angleTan = tan( angle );\n\t\tfloat startDistance = light.radius / max( angleTan, EPSILON );\n\n\t\tvec3 randomPos = light.position - normal * startDistance + u * x + v * y;\n\t\tvec3 toLight = randomPos - rayOrigin;\n\t\tfloat lightDistSq = dot( toLight, toLight );\n\t\tfloat dist = sqrt( lightDistSq );\n\n\t\tvec3 direction = toLight / max( dist, EPSILON );\n\t\tfloat cosTheta = dot( direction, normal );\n\n\t\tfloat spotAttenuation = light.iesProfile != - 1 ?\n\t\t\tgetPhotometricAttenuation( iesProfiles, light.iesProfile, direction, normal, u, v ) :\n\t\t\tgetSpotAttenuation( light.coneCos, light.penumbraCos, cosTheta );\n\n\t\tfloat distanceAttenuation = getDistanceAttenuation( dist, light.distance, light.decay );\n\t\tLightSampleRecord lightSampleRec;\n\t\tlightSampleRec.type = light.type;\n\t\tlightSampleRec.dist = dist;\n\t\tlightSampleRec.direction = direction;\n\t\tlightSampleRec.emission = light.color * light.intensity * distanceAttenuation * spotAttenuation;\n\t\tlightSampleRec.pdf = 1.0;\n\n\t\treturn lightSampleRec;\n\n\t}\n\n\tLightSampleRecord randomLightSample( sampler2D lights, sampler2DArray iesProfiles, uint lightCount, vec3 rayOrigin, vec3 ruv ) {\n\n\t\t// pick a random light\n\t\tuint l = uint( ruv.x * float( lightCount ) );\n\t\tLight light = readLightInfo( lights, l );\n\n\t\tif ( light.type == SPOT_LIGHT_TYPE ) {\n\n\t\t\treturn randomSpotLightSample( light, iesProfiles, rayOrigin, ruv.yz );\n\n\t\t} else if ( light.type == POINT_LIGHT_TYPE ) {\n\n\t\t\tvec3 lightRay = light.u - rayOrigin;\n\t\t\tfloat lightDist = length( lightRay );\n\t\t\tfloat cutoffDistance = light.distance;\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDist, light.decay ), 0.01 );\n\t\t\tif ( cutoffDistance > 0.0 ) {\n\n\t\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDist / cutoffDistance ) ) );\n\n\t\t\t}\n\n\t\t\tLightSampleRecord rec;\n\t\t\trec.direction = normalize( lightRay );\n\t\t\trec.dist = length( lightRay );\n\t\t\trec.pdf = 1.0;\n\t\t\trec.emission = light.color * light.intensity * distanceFalloff;\n\t\t\trec.type = light.type;\n\t\t\treturn rec;\n\n\t\t} else if ( light.type == DIR_LIGHT_TYPE ) {\n\n\t\t\tLightSampleRecord rec;\n\t\t\trec.dist = 1e10;\n\t\t\trec.direction = light.u;\n\t\t\trec.pdf = 1.0;\n\t\t\trec.emission = light.color * light.intensity;\n\t\t\trec.type = light.type;\n\n\t\t\treturn rec;\n\n\t\t} else {\n\n\t\t\t// sample the light\n\t\t\treturn randomAreaLightSample( light, rayOrigin, ruv.yz );\n\n\t\t}\n\n\t}\n\n"})),r.register("59dZo",(function(e,n){t(e.exports,"intersectShapesGLSL",(()=>a));const a="\n\n\t// Finds the point where the ray intersects the plane defined by u and v and checks if this point\n\t// falls in the bounds of the rectangle on that same plane.\n\t// Plane intersection: https://lousodrome.net/blog/light/2020/07/03/intersection-of-a-ray-and-a-plane/\n\tbool intersectsRectangle( vec3 center, vec3 normal, vec3 u, vec3 v, vec3 rayOrigin, vec3 rayDirection, out float dist ) {\n\n\t\tfloat t = dot( center - rayOrigin, normal ) / dot( rayDirection, normal );\n\n\t\tif ( t > EPSILON ) {\n\n\t\t\tvec3 p = rayOrigin + rayDirection * t;\n\t\t\tvec3 vi = p - center;\n\n\t\t\t// check if p falls inside the rectangle\n\t\t\tfloat a1 = dot( u, vi );\n\t\t\tif ( abs( a1 ) <= 0.5 ) {\n\n\t\t\t\tfloat a2 = dot( v, vi );\n\t\t\t\tif ( abs( a2 ) <= 0.5 ) {\n\n\t\t\t\t\tdist = t;\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t// Finds the point where the ray intersects the plane defined by u and v and checks if this point\n\t// falls in the bounds of the circle on that same plane. See above URL for a description of the plane intersection algorithm.\n\tbool intersectsCircle( vec3 position, vec3 normal, vec3 u, vec3 v, vec3 rayOrigin, vec3 rayDirection, out float dist ) {\n\n\t\tfloat t = dot( position - rayOrigin, normal ) / dot( rayDirection, normal );\n\n\t\tif ( t > EPSILON ) {\n\n\t\t\tvec3 hit = rayOrigin + rayDirection * t;\n\t\t\tvec3 vi = hit - position;\n\n\t\t\tfloat a1 = dot( u, vi );\n\t\t\tfloat a2 = dot( v, vi );\n\n\t\t\tif( length( vec2( a1, a2 ) ) <= 0.5 ) {\n\n\t\t\t\tdist = t;\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n"})),r.register("Cp64s",(function(e,n){t(e.exports,"mathGLSL",(()=>a));const a="\n\n\t// Fast arccos approximation used to remove banding artifacts caused by numerical errors in acos.\n\t// This is a cubic Lagrange interpolating polynomial for x = [-1, -1/2, 0, 1/2, 1].\n\t// For more information see: https://github.com/gkjohnson/three-gpu-pathtracer/pull/171#issuecomment-1152275248\n\tfloat acosApprox( float x ) {\n\n\t\tx = clamp( x, -1.0, 1.0 );\n\t\treturn ( - 0.69813170079773212 * x * x - 0.87266462599716477 ) * x + 1.5707963267948966;\n\n\t}\n\n\t// An acos with input values bound to the range [-1, 1].\n\tfloat acosSafe( float x ) {\n\n\t\treturn acos( clamp( x, -1.0, 1.0 ) );\n\n\t}\n\n\tfloat saturateCos( float val ) {\n\n\t\treturn clamp( val, 0.001, 1.0 );\n\n\t}\n\n\tfloat square( float t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec2 square( vec2 t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec3 square( vec3 t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec4 square( vec4 t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec2 rotateVector( vec2 v, float t ) {\n\n\t\tfloat ac = cos( t );\n\t\tfloat as = sin( t );\n\t\treturn vec2(\n\t\t\tv.x * ac - v.y * as,\n\t\t\tv.x * as + v.y * ac\n\t\t);\n\n\t}\n\n\t// forms a basis with the normal vector as Z\n\tmat3 getBasisFromNormal( vec3 normal ) {\n\n\t\tvec3 other;\n\t\tif ( abs( normal.x ) > 0.5 ) {\n\n\t\t\tother = vec3( 0.0, 1.0, 0.0 );\n\n\t\t} else {\n\n\t\t\tother = vec3( 1.0, 0.0, 0.0 );\n\n\t\t}\n\n\t\tvec3 ortho = normalize( cross( normal, other ) );\n\t\tvec3 ortho2 = normalize( cross( normal, ortho ) );\n\t\treturn mat3( ortho2, ortho, normal );\n\n\t}\n\n"})),r.register("ibAuh",(function(e,n){t(e.exports,"fresnelGLSL",(()=>a));const a="\n\n\tbool totalInternalReflection( float cosTheta, float eta ) {\n\n\t\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\t\treturn eta * sinTheta > 1.0;\n\n\t}\n\n\t// https://google.github.io/filament/Filament.md.html#materialsystem/diffusebrdf\n\tfloat schlickFresnel( float cosine, float f0 ) {\n\n\t\treturn f0 + ( 1.0 - f0 ) * pow( 1.0 - cosine, 5.0 );\n\n\t}\n\n\tvec3 schlickFresnel( float cosine, vec3 f0 ) {\n\n\t\treturn f0 + ( 1.0 - f0 ) * pow( 1.0 - cosine, 5.0 );\n\n\t}\n\n\tvec3 schlickFresnel( float cosine, vec3 f0, vec3 f90 ) {\n\n\t\treturn f0 + ( f90 - f0 ) * pow( 1.0 - cosine, 5.0 );\n\n\t}\n\n\tfloat dielectricFresnel( float cosThetaI, float eta ) {\n\n\t\t// https://schuttejoe.github.io/post/disneybsdf/\n\t\tfloat ni = eta;\n\t\tfloat nt = 1.0;\n\n\t\t// Check for total internal reflection\n\t\tfloat sinThetaISq = 1.0f - cosThetaI * cosThetaI;\n\t\tfloat sinThetaTSq = eta * eta * sinThetaISq;\n\t\tif( sinThetaTSq >= 1.0 ) {\n\n\t\t\treturn 1.0;\n\n\t\t}\n\n\t\tfloat sinThetaT = sqrt( sinThetaTSq );\n\n\t\tfloat cosThetaT = sqrt( max( 0.0, 1.0f - sinThetaT * sinThetaT ) );\n\t\tfloat rParallel = ( ( nt * cosThetaI ) - ( ni * cosThetaT ) ) / ( ( nt * cosThetaI ) + ( ni * cosThetaT ) );\n\t\tfloat rPerpendicular = ( ( ni * cosThetaI ) - ( nt * cosThetaT ) ) / ( ( ni * cosThetaI ) + ( nt * cosThetaT ) );\n\t\treturn ( rParallel * rParallel + rPerpendicular * rPerpendicular ) / 2.0;\n\n\t}\n\n\t// https://raytracing.github.io/books/RayTracingInOneWeekend.html#dielectrics/schlickapproximation\n\tfloat iorRatioToF0( float eta ) {\n\n\t\treturn pow( ( 1.0 - eta ) / ( 1.0 + eta ), 2.0 );\n\n\t}\n\n\tvec3 evaluateFresnel( float cosTheta, float eta, vec3 f0, vec3 f90 ) {\n\n\t\tif ( totalInternalReflection( cosTheta, eta ) ) {\n\n\t\t\treturn f90;\n\n\t\t}\n\n\t\treturn schlickFresnel( cosTheta, f0, f90 );\n\n\t}\n\n\tfloat evaluateFresnelWeight( float cosTheta, float eta, float f0 ) {\n\n\t\tif ( totalInternalReflection( cosTheta, eta ) ) {\n\n\t\t\treturn 1.0;\n\n\t\t}\n\n\t\treturn schlickFresnel( cosTheta, f0 );\n\n\t}\n\n\t/*\n\t// https://schuttejoe.github.io/post/disneybsdf/\n\tfloat disneyFresnel( vec3 wo, vec3 wi, vec3 wh, float f0, float eta, float metalness ) {\n\n\t\tfloat dotHV = dot( wo, wh );\n\t\tfloat dotHL = dot( wi, wh );\n\n\t\tfloat dielectricFresnel = dielectricFresnel( abs( dotHV ), eta );\n\t\tfloat metallicFresnel = schlickFresnel( dotHL, f0 );\n\n\t\treturn mix( dielectricFresnel, metallicFresnel, metalness );\n\n\t}\n\t*/\n"})),r.register("hDPBH",(function(e,n){t(e.exports,"arraySamplerTexelFetchGLSL",(()=>a));const a="\n\n\t// add texel fetch functions for texture arrays\n\tvec4 texelFetch1D( sampler2DArray tex, int layer, uint index ) {\n\n\t\tuint width = uint( textureSize( tex, 0 ).x );\n\t\tuvec2 uv;\n\t\tuv.x = index % width;\n\t\tuv.y = index / width;\n\n\t\treturn texelFetch( tex, ivec3( uv, layer ), 0 );\n\n\t}\n\n\tvec4 textureSampleBarycoord( sampler2DArray tex, int layer, vec3 barycoord, uvec3 faceIndices ) {\n\n\t\treturn\n\t\t\tbarycoord.x * texelFetch1D( tex, layer, faceIndices.x ) +\n\t\t\tbarycoord.y * texelFetch1D( tex, layer, faceIndices.y ) +\n\t\t\tbarycoord.z * texelFetch1D( tex, layer, faceIndices.z );\n\n\t}\n\n"})),r.register("kB2W0",(function(e,n){t(e.exports,"cameraUtilsGLSL",(()=>a));const a="\n\n\tvec3 ndcToRayOrigin( vec2 coord ) {\n\n\t\tvec4 rayOrigin4 = cameraWorldMatrix * invProjectionMatrix * vec4( coord, - 1.0, 1.0 );\n\t\treturn rayOrigin4.xyz / rayOrigin4.w;\n\t}\n\n\tvoid getCameraRay( out vec3 rayDirection, out vec3 rayOrigin ) {\n\n\t\tvec2 ssd = vec2( 1.0 ) / resolution;\n\n\t\t// Jitter the camera ray by finding a uv coordinate at a random sample\n\t\t// around this pixel's UV coordinate for AA\n\t\tvec2 ruv = sobol2( 0 );\n\t\tvec2 jitteredUv = vUv + vec2( tentFilter( ruv.x ) * ssd.x, tentFilter( ruv.y ) * ssd.y );\n\n\t\t#if CAMERA_TYPE == 2\n\n\t\t\t// Equirectangular projection\n\t\t\tvec4 rayDirection4 = vec4( equirectUvToDirection( jitteredUv ), 0.0 );\n\t\t\tvec4 rayOrigin4 = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\trayDirection4 = cameraWorldMatrix * rayDirection4;\n\t\t\trayOrigin4 = cameraWorldMatrix * rayOrigin4;\n\n\t\t\trayDirection = normalize( rayDirection4.xyz );\n\t\t\trayOrigin = rayOrigin4.xyz / rayOrigin4.w;\n\n\t\t#else\n\n\t\t\t// get [- 1, 1] normalized device coordinates\n\t\t\tvec2 ndc = 2.0 * jitteredUv - vec2( 1.0 );\n\t\t\trayOrigin = ndcToRayOrigin( ndc );\n\n\t\t\t#if CAMERA_TYPE == 1\n\n\t\t\t\t// Orthographic projection\n\t\t\t\trayDirection = ( cameraWorldMatrix * vec4( 0.0, 0.0, - 1.0, 0.0 ) ).xyz;\n\t\t\t\trayDirection = normalize( rayDirection );\n\n\t\t\t#else\n\n\t\t\t\t// Perspective projection\n\t\t\t\trayDirection = normalize( mat3(cameraWorldMatrix) * ( invProjectionMatrix * vec4( ndc, 0.0, 1.0 ) ).xyz );\n\n\t\t\t#endif\n\n\t\t#endif\n\n\t\t#if FEATURE_DOF\n\t\t{\n\n\t\t\t// depth of field\n\t\t\tvec3 focalPoint = rayOrigin + normalize( rayDirection ) * physicalCamera.focusDistance;\n\n\t\t\t// get the aperture sample\n\t\t\t// if blades === 0 then we assume a circle\n\t\t\tvec3 shapeUVW= sobol3( 1 );\n\t\t\tint blades = physicalCamera.apertureBlades;\n\t\t\tfloat anamorphicRatio = physicalCamera.anamorphicRatio;\n\t\t\tvec2 apertureSample = blades == 0 ? sampleCircle( shapeUVW.xy ) : sampleRegularPolygon( blades, shapeUVW );\n\t\t\tapertureSample *= physicalCamera.bokehSize * 0.5 * 1e-3;\n\n\t\t\t// rotate the aperture shape\n\t\t\tapertureSample =\n\t\t\t\trotateVector( apertureSample, physicalCamera.apertureRotation ) *\n\t\t\t\tsaturate( vec2( anamorphicRatio, 1.0 / anamorphicRatio ) );\n\n\t\t\t// create the new ray\n\t\t\trayOrigin += ( cameraWorldMatrix * vec4( apertureSample, 0.0, 0.0 ) ).xyz;\n\t\t\trayDirection = focalPoint - rayOrigin;\n\n\t\t}\n\t\t#endif\n\n\t\trayDirection = normalize( rayDirection );\n\n\t}\n\n"})),r.register("9h5et",(function(e,n){t(e.exports,"attenuateHitGLSL",(()=>a));const a="\n\n\t// step through multiple surface hits and accumulate color attenuation based on transmissive surfaces\n\t// returns true if a solid surface was hit\n\tbool attenuateHit(\n\t\tBVH bvh, vec3 rayOrigin, vec3 rayDirection, float rayDist,\n\t\tint traversals, int transmissiveTraversals, bool isShadowRay,\n\t\tMaterial fogMaterial,\n\t\tout vec3 color\n\t) {\n\n\t\tvec3 ogRayOrigin = rayOrigin;\n\n\t\t// hit results\n\t\tuvec4 faceIndices = uvec4( 0u );\n\t\tvec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\n\t\tvec3 barycoord = vec3( 0.0 );\n\t\tfloat side = 1.0;\n\t\tfloat dist = 0.0;\n\t\tLightSampleRecord lightSampleRec;\n\n\t\tcolor = vec3( 1.0 );\n\n\t\t// TODO: we should be using sobol sampling here instead of rand but the sobol bounce and path indices need to be incremented\n\t\t// and then reset.\n\t\tfor ( int i = 0; i < traversals; i ++ ) {\n\n\t\t\tint hitType = traceScene(\n\t\t\t\trayOrigin, rayDirection,\n\t\t\t\tbvh, lights, fogMaterial,\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, dist,\n\t\t\t\tlightSampleRec\n\t\t\t);\n\n\t\t\tif ( hitType == FOG_HIT ) {\n\n\t\t\t\treturn true;\n\n\t\t\t} else if ( hitType == LIGHT_HIT ) {\n\n\t\t\t\tfloat totalDist = distance( ogRayOrigin, rayOrigin + rayDirection * lightSampleRec.dist );\n\t\t\t\treturn totalDist < rayDist - max( totalDist, rayDist ) * 1e-4;\n\n\t\t\t} else if ( hitType == SURFACE_HIT ) {\n\n\t\t\t\tfloat totalDist = distance( ogRayOrigin, rayOrigin + rayDirection * dist );\n\t\t\t\tif ( totalDist > rayDist ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\t// TODO: attenuate the contribution based on the PDF of the resulting ray including refraction values\n\t\t\t\t// Should be able to work using the material BSDF functions which will take into account specularity, etc.\n\t\t\t\t// TODO: should we account for emissive surfaces here?\n\n\t\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, faceIndices.x ).r;\n\t\t\t\tMaterial material = readMaterialInfo( materials, materialIndex );\n\n\t\t\t\t// adjust the ray to the new surface\n\t\t\t\tbool isEntering = side == 1.0;\n\t\t\t\trayOrigin = stepRayOrigin( rayOrigin, rayDirection, - faceNormal, dist );\n\n\t\t\t\t#if FEATURE_FOG\n\n\t\t\t\tif ( material.fogVolume ) {\n\n\t\t\t\t\tfogMaterial = material;\n\t\t\t\t\tfogMaterial.fogVolume = side == 1.0;\n\t\t\t\t\ti -= sign( transmissiveTraversals );\n\t\t\t\t\ttransmissiveTraversals --;\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t\tif ( ! material.castShadow && isShadowRay ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tvec2 uv = textureSampleBarycoord( attributesArray, ATTR_UV, barycoord, faceIndices.xyz ).xy;\n\t\t\t\tvec4 vertexColor = textureSampleBarycoord( attributesArray, ATTR_COLOR, barycoord, faceIndices.xyz );\n\n\t\t\t\t// albedo\n\t\t\t\tvec4 albedo = vec4( material.color, material.opacity );\n\t\t\t\tif ( material.map != - 1 ) {\n\n\t\t\t\t\tvec3 uvPrime = material.mapTransform * vec3( uv, 1 );\n\t\t\t\t\talbedo *= texture2D( textures, vec3( uvPrime.xy, material.map ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.vertexColors ) {\n\n\t\t\t\t\talbedo *= vertexColor;\n\n\t\t\t\t}\n\n\t\t\t\t// alphaMap\n\t\t\t\tif ( material.alphaMap != - 1 ) {\n\n\t\t\t\t\talbedo.a *= texture2D( textures, vec3( uv, material.alphaMap ) ).x;\n\n\t\t\t\t}\n\n\t\t\t\t// transmission\n\t\t\t\tfloat transmission = material.transmission;\n\t\t\t\tif ( material.transmissionMap != - 1 ) {\n\n\t\t\t\t\tvec3 uvPrime = material.transmissionMapTransform * vec3( uv, 1 );\n\t\t\t\t\ttransmission *= texture2D( textures, vec3( uvPrime.xy, material.transmissionMap ) ).r;\n\n\t\t\t\t}\n\n\t\t\t\t// metalness\n\t\t\t\tfloat metalness = material.metalness;\n\t\t\t\tif ( material.metalnessMap != - 1 ) {\n\n\t\t\t\t\tvec3 uvPrime = material.metalnessMapTransform * vec3( uv, 1 );\n\t\t\t\t\tmetalness *= texture2D( textures, vec3( uvPrime.xy, material.metalnessMap ) ).b;\n\n\t\t\t\t}\n\n\t\t\t\tfloat alphaTest = material.alphaTest;\n\t\t\t\tbool useAlphaTest = alphaTest != 0.0;\n\t\t\t\tfloat transmissionFactor = ( 1.0 - metalness ) * transmission;\n\t\t\t\tif (\n\t\t\t\t\ttransmissionFactor < rand() && ! (\n\t\t\t\t\t\t// material sidedness\n\t\t\t\t\t\tmaterial.side != 0.0 && side == material.side\n\n\t\t\t\t\t\t// alpha test\n\t\t\t\t\t\t|| useAlphaTest && albedo.a < alphaTest\n\n\t\t\t\t\t\t// opacity\n\t\t\t\t\t\t|| material.transparent && ! useAlphaTest && albedo.a < rand()\n\t\t\t\t\t)\n\t\t\t\t) {\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( side == 1.0 && isEntering ) {\n\n\t\t\t\t\t// only attenuate by surface color on the way in\n\t\t\t\t\tcolor *= mix( vec3( 1.0 ), albedo.rgb, transmissionFactor );\n\n\t\t\t\t} else if ( side == - 1.0 ) {\n\n\t\t\t\t\t// attenuate by medium once we hit the opposite side of the model\n\t\t\t\t\tcolor *= transmissionAttenuation( dist, material.attenuationColor, material.attenuationDistance );\n\n\t\t\t\t}\n\n\t\t\t\tbool isTransmissiveRay = dot( rayDirection, faceNormal * side ) < 0.0;\n\t\t\t\tif ( ( isTransmissiveRay || isEntering ) && transmissiveTraversals > 0 ) {\n\n\t\t\t\t\ti -= sign( transmissiveTraversals );\n\t\t\t\t\ttransmissiveTraversals --;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n"})),r.register("lrWoU",(function(e,n){t(e.exports,"traceSceneGLSL",(()=>a));const a="\n\n\t#define NO_HIT 0\n\t#define SURFACE_HIT 1\n\t#define LIGHT_HIT 2\n\t#define FOG_HIT 3\n\n\tint traceScene(\n\n\t\tvec3 rayOrigin, vec3 rayDirection,\n\t\tBVH bvh, LightsInfo lights, Material fogMaterial,\n\t\tout uvec4 faceIndices, out vec3 faceNormal, out vec3 barycoord, out float side, out float dist,\n\t\tout LightSampleRecord lightSampleRec\n\n\t) {\n\n\t\tbool hit = bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist );\n\t\tbool lightHit = lightsClosestHit( lights.tex, lights.count, rayOrigin, rayDirection, lightSampleRec );\n\n\t\t#if FEATURE_FOG\n\n\t\tif ( fogMaterial.fogVolume ) {\n\n\t\t\tfloat particleDist = intersectFogVolume( fogMaterial, sobol( 1 ) );\n\t\t\tif ( particleDist + 1e-4 < dist && ( particleDist + 1e-4 < lightSampleRec.dist || ! lightHit ) ) {\n\n\t\t\t\tside = 1.0;\n\t\t\t\tfaceNormal = normalize( - rayDirection );\n\t\t\t\tdist = particleDist;\n\t\t\t\treturn FOG_HIT;\n\n\t\t\t}\n\n\t\t}\n\n\t\t#endif\n\n\t\tif ( lightHit && ( lightSampleRec.dist < dist || ! hit ) ) {\n\n\t\t\treturn LIGHT_HIT;\n\n\t\t}\n\n\t\tif ( hit ) {\n\n\t\t\treturn SURFACE_HIT;\n\n\t\t}\n\n\t\treturn NO_HIT;\n\n\t}\n\n"})),r.register("auGOd",(function(e,n){t(e.exports,"getSurfaceRecordGLSL",(()=>a));const a="\n\n\t#define SKIP_SURFACE 0\n\t#define HIT_SURFACE 1\n\tint getSurfaceRecord(\n\t\tMaterial material, sampler2DArray attributesArray,\n\t\tfloat side, vec3 barycoord, uvec4 faceIndices, vec3 faceNormal, float accumulatedRoughness,\n\n\t\tout SurfaceRecord surf\n\t) {\n\n\t\tif ( material.fogVolume ) {\n\n\t\t\tvec3 normal = vec3( 0, 0, 1 );\n\n\t\t\tSurfaceRecord fogSurface;\n\t\t\tfogSurface.volumeParticle = true;\n\t\t\tfogSurface.color = material.color;\n\t\t\tfogSurface.emission = material.emissiveIntensity * material.emissive;\n\t\t\tfogSurface.normal = normal;\n\t\t\tfogSurface.faceNormal = normal;\n\t\t\tfogSurface.clearcoatNormal = normal;\n\n\t\t\tsurf = fogSurface;\n\t\t\treturn HIT_SURFACE;\n\n\t\t}\n\n\t\t// uv coord for textures\n\t\tvec2 uv = textureSampleBarycoord( attributesArray, ATTR_UV, barycoord, faceIndices.xyz ).xy;\n\t\tvec4 vertexColor = textureSampleBarycoord( attributesArray, ATTR_COLOR, barycoord, faceIndices.xyz );\n\n\t\t// albedo\n\t\tvec4 albedo = vec4( material.color, material.opacity );\n\t\tif ( material.map != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.mapTransform * vec3( uv, 1 );\n\t\t\talbedo *= texture2D( textures, vec3( uvPrime.xy, material.map ) );\n\t\t}\n\n\t\tif ( material.vertexColors ) {\n\n\t\t\talbedo *= vertexColor;\n\n\t\t}\n\n\t\t// alphaMap\n\t\tif ( material.alphaMap != - 1 ) {\n\n\t\t\talbedo.a *= texture2D( textures, vec3( uv, material.alphaMap ) ).x;\n\n\t\t}\n\n\t\t// possibly skip this sample if it's transparent, alpha test is enabled, or we hit the wrong material side\n\t\t// and it's single sided.\n\t\t// - alpha test is disabled when it === 0\n\t\t// - the material sidedness test is complicated because we want light to pass through the back side but still\n\t\t// be able to see the front side. This boolean checks if the side we hit is the front side on the first ray\n\t\t// and we're rendering the other then we skip it. Do the opposite on subsequent bounces to get incoming light.\n\t\tfloat alphaTest = material.alphaTest;\n\t\tbool useAlphaTest = alphaTest != 0.0;\n\t\tif (\n\t\t\t// material sidedness\n\t\t\tmaterial.side != 0.0 && side != material.side\n\n\t\t\t// alpha test\n\t\t\t|| useAlphaTest && albedo.a < alphaTest\n\n\t\t\t// opacity\n\t\t\t|| material.transparent && ! useAlphaTest && albedo.a < sobol( 3 )\n\t\t) {\n\n\t\t\treturn SKIP_SURFACE;\n\n\t\t}\n\n\t\t// fetch the interpolated smooth normal\n\t\tvec3 normal = normalize( textureSampleBarycoord(\n\t\t\tattributesArray,\n\t\t\tATTR_NORMAL,\n\t\t\tbarycoord,\n\t\t\tfaceIndices.xyz\n\t\t).xyz );\n\n\t\t// roughness\n\t\tfloat roughness = material.roughness;\n\t\tif ( material.roughnessMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.roughnessMapTransform * vec3( uv, 1 );\n\t\t\troughness *= texture2D( textures, vec3( uvPrime.xy, material.roughnessMap ) ).g;\n\n\t\t}\n\n\t\t// metalness\n\t\tfloat metalness = material.metalness;\n\t\tif ( material.metalnessMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.metalnessMapTransform * vec3( uv, 1 );\n\t\t\tmetalness *= texture2D( textures, vec3( uvPrime.xy, material.metalnessMap ) ).b;\n\n\t\t}\n\n\t\t// emission\n\t\tvec3 emission = material.emissiveIntensity * material.emissive;\n\t\tif ( material.emissiveMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.emissiveMapTransform * vec3( uv, 1 );\n\t\t\temission *= texture2D( textures, vec3( uvPrime.xy, material.emissiveMap ) ).xyz;\n\n\t\t}\n\n\t\t// transmission\n\t\tfloat transmission = material.transmission;\n\t\tif ( material.transmissionMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.transmissionMapTransform * vec3( uv, 1 );\n\t\t\ttransmission *= texture2D( textures, vec3( uvPrime.xy, material.transmissionMap ) ).r;\n\n\t\t}\n\n\t\t// normal\n\t\tif ( material.flatShading ) {\n\n\t\t\t// if we're rendering a flat shaded object then use the face normals - the face normal\n\t\t\t// is provided based on the side the ray hits the mesh so flip it to align with the\n\t\t\t// interpolated vertex normals.\n\t\t\tnormal = faceNormal * side;\n\n\t\t}\n\n\t\tvec3 baseNormal = normal;\n\t\tif ( material.normalMap != - 1 ) {\n\n\t\t\tvec4 tangentSample = textureSampleBarycoord(\n\t\t\t\tattributesArray,\n\t\t\t\tATTR_TANGENT,\n\t\t\t\tbarycoord,\n\t\t\t\tfaceIndices.xyz\n\t\t\t);\n\n\t\t\t// some provided tangents can be malformed (0, 0, 0) causing the normal to be degenerate\n\t\t\t// resulting in NaNs and slow path tracing.\n\t\t\tif ( length( tangentSample.xyz ) > 0.0 ) {\n\n\t\t\t\tvec3 tangent = normalize( tangentSample.xyz );\n\t\t\t\tvec3 bitangent = normalize( cross( normal, tangent ) * tangentSample.w );\n\t\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\n\t\t\t\tvec3 uvPrime = material.normalMapTransform * vec3( uv, 1 );\n\t\t\t\tvec3 texNormal = texture2D( textures, vec3( uvPrime.xy, material.normalMap ) ).xyz * 2.0 - 1.0;\n\t\t\t\ttexNormal.xy *= material.normalScale;\n\t\t\t\tnormal = vTBN * texNormal;\n\n\t\t\t}\n\n\t\t}\n\n\t\tnormal *= side;\n\n\t\t// clearcoat\n\t\tfloat clearcoat = material.clearcoat;\n\t\tif ( material.clearcoatMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.clearcoatMapTransform * vec3( uv, 1 );\n\t\t\tclearcoat *= texture2D( textures, vec3( uvPrime.xy, material.clearcoatMap ) ).r;\n\n\t\t}\n\n\t\t// clearcoatRoughness\n\t\tfloat clearcoatRoughness = material.clearcoatRoughness;\n\t\tif ( material.clearcoatRoughnessMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.clearcoatRoughnessMapTransform * vec3( uv, 1 );\n\t\t\tclearcoatRoughness *= texture2D( textures, vec3( uvPrime.xy, material.clearcoatRoughnessMap ) ).g;\n\n\t\t}\n\n\t\t// clearcoatNormal\n\t\tvec3 clearcoatNormal = baseNormal;\n\t\tif ( material.clearcoatNormalMap != - 1 ) {\n\n\t\t\tvec4 tangentSample = textureSampleBarycoord(\n\t\t\t\tattributesArray,\n\t\t\t\tATTR_TANGENT,\n\t\t\t\tbarycoord,\n\t\t\t\tfaceIndices.xyz\n\t\t\t);\n\n\t\t\t// some provided tangents can be malformed (0, 0, 0) causing the normal to be degenerate\n\t\t\t// resulting in NaNs and slow path tracing.\n\t\t\tif ( length( tangentSample.xyz ) > 0.0 ) {\n\n\t\t\t\tvec3 tangent = normalize( tangentSample.xyz );\n\t\t\t\tvec3 bitangent = normalize( cross( clearcoatNormal, tangent ) * tangentSample.w );\n\t\t\t\tmat3 vTBN = mat3( tangent, bitangent, clearcoatNormal );\n\n\t\t\t\tvec3 uvPrime = material.clearcoatNormalMapTransform * vec3( uv, 1 );\n\t\t\t\tvec3 texNormal = texture2D( textures, vec3( uvPrime.xy, material.clearcoatNormalMap ) ).xyz * 2.0 - 1.0;\n\t\t\t\ttexNormal.xy *= material.clearcoatNormalScale;\n\t\t\t\tclearcoatNormal = vTBN * texNormal;\n\n\t\t\t}\n\n\t\t}\n\n\t\tclearcoatNormal *= side;\n\n\t\t// sheenColor\n\t\tvec3 sheenColor = material.sheenColor;\n\t\tif ( material.sheenColorMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.sheenColorMapTransform * vec3( uv, 1 );\n\t\t\tsheenColor *= texture2D( textures, vec3( uvPrime.xy, material.sheenColorMap ) ).rgb;\n\n\t\t}\n\n\t\t// sheenRoughness\n\t\tfloat sheenRoughness = material.sheenRoughness;\n\t\tif ( material.sheenRoughnessMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.sheenRoughnessMapTransform * vec3( uv, 1 );\n\t\t\tsheenRoughness *= texture2D( textures, vec3( uvPrime.xy, material.sheenRoughnessMap ) ).a;\n\n\t\t}\n\n\t\t// iridescence\n\t\tfloat iridescence = material.iridescence;\n\t\tif ( material.iridescenceMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.iridescenceMapTransform * vec3( uv, 1 );\n\t\t\tiridescence *= texture2D( textures, vec3( uvPrime.xy, material.iridescenceMap ) ).r;\n\n\t\t}\n\n\t\t// iridescence thickness\n\t\tfloat iridescenceThickness = material.iridescenceThicknessMaximum;\n\t\tif ( material.iridescenceThicknessMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.iridescenceThicknessMapTransform * vec3( uv, 1 );\n\t\t\tfloat iridescenceThicknessSampled = texture2D( textures, vec3( uvPrime.xy, material.iridescenceThicknessMap ) ).g;\n\t\t\tiridescenceThickness = mix( material.iridescenceThicknessMinimum, material.iridescenceThicknessMaximum, iridescenceThicknessSampled );\n\n\t\t}\n\n\t\tiridescence = iridescenceThickness == 0.0 ? 0.0 : iridescence;\n\n\t\t// specular color\n\t\tvec3 specularColor = material.specularColor;\n\t\tif ( material.specularColorMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.specularColorMapTransform * vec3( uv, 1 );\n\t\t\tspecularColor *= texture2D( textures, vec3( uvPrime.xy, material.specularColorMap ) ).rgb;\n\n\t\t}\n\n\t\t// specular intensity\n\t\tfloat specularIntensity = material.specularIntensity;\n\t\tif ( material.specularIntensityMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.specularIntensityMapTransform * vec3( uv, 1 );\n\t\t\tspecularIntensity *= texture2D( textures, vec3( uvPrime.xy, material.specularIntensityMap ) ).a;\n\n\t\t}\n\n\t\tsurf.volumeParticle = false;\n\n\t\tsurf.faceNormal = faceNormal;\n\t\tsurf.normal = normal;\n\n\t\tsurf.metalness = metalness;\n\t\tsurf.color = albedo.rgb;\n\t\tsurf.emission = emission;\n\n\t\tsurf.ior = material.ior;\n\t\tsurf.transmission = transmission;\n\t\tsurf.thinFilm = material.thinFilm;\n\t\tsurf.attenuationColor = material.attenuationColor;\n\t\tsurf.attenuationDistance = material.attenuationDistance;\n\n\t\tsurf.clearcoatNormal = clearcoatNormal;\n\t\tsurf.clearcoat = clearcoat;\n\n\t\tsurf.sheen = material.sheen;\n\t\tsurf.sheenColor = sheenColor;\n\n\t\tsurf.iridescence = iridescence;\n\t\tsurf.iridescenceIor = material.iridescenceIor;\n\t\tsurf.iridescenceThickness = iridescenceThickness;\n\n\t\tsurf.specularColor = specularColor;\n\t\tsurf.specularIntensity = specularIntensity;\n\n\t\t// apply perceptual roughness factor from gltf. sheen perceptual roughness is\n\t\t// applied by its brdf function\n\t\t// https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#microfacet-surfaces\n\t\tsurf.roughness = roughness * roughness;\n\t\tsurf.clearcoatRoughness = clearcoatRoughness * clearcoatRoughness;\n\t\tsurf.sheenRoughness = sheenRoughness;\n\n\t\t// frontFace is used to determine transmissive properties and PDF. If no transmission is used\n\t\t// then we can just always assume this is a front face.\n\t\tsurf.frontFace = side == 1.0 || transmission == 0.0;\n\t\tsurf.eta = material.thinFilm || surf.frontFace ? 1.0 / material.ior : material.ior;\n\t\tsurf.f0 = iorRatioToF0( surf.eta );\n\n\t\t// Compute the filtered roughness value to use during specular reflection computations.\n\t\t// The accumulated roughness value is scaled by a user setting and a \"magic value\" of 5.0.\n\t\t// If we're exiting something transmissive then scale the factor down significantly so we can retain\n\t\t// sharp internal reflections\n\t\tsurf.filteredRoughness = applyFilteredGlossy( surf.roughness, accumulatedRoughness );\n\t\tsurf.filteredClearcoatRoughness = applyFilteredGlossy( surf.clearcoatRoughness, accumulatedRoughness );\n\n\t\treturn HIT_SURFACE;\n\n\t}\n"})),r.register("11ZPe",(function(e,n){t(e.exports,"FogVolumeMaterial",(()=>i));var a=r("ilwiq");class i extends a.MeshStandardMaterial{constructor(t){super(t),this.isFogVolumeMaterial=!0,this.density=.015,this.emissive=new a.Color,this.emissiveIntensity=0,this.opacity=.15,this.transparent=!0,this.roughness=1,this.metalness=0,this.setValues(t)}}}));
//# sourceMappingURL=areaLight.696bb446.js.map
